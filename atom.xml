<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>君霖的blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-29T10:13:04.341Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Bean</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对JMM与happen-before的理解</title>
    <link href="http://example.com/2022/10/29/%E5%AF%B9JMM%E4%B8%8Ehappen-before%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2022/10/29/%E5%AF%B9JMM%E4%B8%8Ehappen-before%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2022-10-29T09:59:00.000Z</published>
    <updated>2022-10-29T10:13:04.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Java-Memory-Model"><a href="#Java-Memory-Model" class="headerlink" title="Java Memory Model"></a>Java Memory Model</h3><p>编写一个程序,我们首先希望它是正确的,其次是快的,如果程序不正确,那么再快也没用.尤其在多线程环境下,如果没有很好处理并发问题,那么很容易导致数据的不一致性,这将产生严重的问题.所以,理解java内存模型-JMM是非常重要的.</p><p>首先来看一下java内存模型的组成:<img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h7m8getq6yj30hu0mujsu.jpg" alt="jmm"></p><p>我们需要知道这样一个非常非常重要的事实,在CPU中运行一个线程,线程所读取到的值可能存放于寄存器,可能存放于缓存中,这些是线程自身所能看到的数据.只有堆上的数据是所有线程都能看到的,也就是说线程共享本地内存.</p><p>我来举一个最简单的情况:</p><p>假如有这么一个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在单线程场景下,执行以下操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Number num = <span class="hljs-keyword">new</span> Number();<br>num.set(<span class="hljs-number">3</span>); <span class="hljs-comment">//设置3</span><br>print(num.get()); <span class="hljs-comment">//打印3</span><br></code></pre></td></tr></table></figure><p>毋庸置疑,这个操作绝对是没有问题的,对num这个对象设置3这个值,即使值没有被刷新到线程共享的本地内存中,帮它存放到缓存中,也不会出现问题.</p><p>那么考虑多线程场景,如果两个线程同时更新和读取a值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Number num = <span class="hljs-keyword">new</span> Number();<br>num.set(<span class="hljs-number">3</span>); <span class="hljs-comment">//设置3 A线程设置</span><br>num.set(<span class="hljs-number">4</span>)；<span class="hljs-comment">//设置4 B线程设置</span><br>print(num.get()); <span class="hljs-comment">//A线程读取</span><br></code></pre></td></tr></table></figure><p>如果程序按照这个顺序执行,那么A线程读取的值,会是3还是4呢,其实两种情况都有可能发生.如果线程B设置的值能写入本地内存,并且线程A不读取缓存中的值,也是读取本地内存中的值,那么读取的值就是3.如果线程直接读取在缓存中的值,那么就会读到3.所以这种代码是有问题的,这种叫做可见性问题.为了解决可见性问题,java提供了一个叫做<strong>volatile</strong>的修饰语,我们将类改成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么按照上面程序的执行顺序会输出什么呢?答案是会输出4.volatile修饰的变量能保证对变量读取和写入都会去直接和本地内存交互,也就是说不会经过缓存,读取直接从本地缓存读取,写入直接写入本地缓存,这样以来会很容易理解为什么会读取到4了.除此之外,volatile还有一个非常重要的特性,它会刷新线程所能看到的其他值到本地内存当中.我们再来举一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>  <br>  <span class="hljs-comment">//A线程执行该代码</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">while</span>(flag) &#123;<br>      <br>   &#125;<br>   a = a - <span class="hljs-number">1</span>; <span class="hljs-comment">//C1</span><br>     flag = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//C2</span><br>  &#125;<br>  <br>  <span class="hljs-comment">//B线程执行该代码</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">while</span>(!flag) &#123;<br>   <br>   &#125;<br>   a = a + <span class="hljs-number">1</span>; <span class="hljs-comment">//P1</span><br> flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//P2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设这里对a的操作是原子操作(其实是三个操作).那么开启两个线程执行上述代码,值都会在0和1之间徘徊,因为每当读取flag的值的时候,顺带也有把a的最新值从本地内存读出来,写入的时候也是一样的.如果volatile只能保证flag被写入本地内存,不能保证a写入到本地内存,那么a一直无法读取到另一个线程的变更,那么可能会出现a=-1或者a=-2等情况,但其实会在写入flag的值的时候,顺带写入a的值,读取的时候也是同样的道理.更新一个volatile变量,顺带把线程操作的其它变量也一起刷新到本地内存去,做这样一件顺便且合理的事情,何乐而不为呢?</p><p>但是计算机为了追求速度,会引进一些优化手段,如<strong>重排序</strong>.重排序会将一些看似没有关联的操作顺序给重新排列,以追求更高的执行速度.在上面这个代码中,P1操作可能会被排序到P2之后进行,即先更新flag的值,再更新a的值,这样一来,flag被写入到本地内存中,因为a的操作还未开始,即使被写入本地内存后还是原值,还是会产生a的值被不确定的读取问题.</p><p>为了防止这种情况,java限制对volatile的这些操作是不能被重排序的,也就是C2和P2两个操作不能被重排序.这样一来,程序就能按照我们的意愿来执行了.</p><h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen Before"></a>Happen Before</h3><p>说到Happen Before规则,有些人可能会被它拗口的一些规则给搞得头昏脑涨.我觉得只要在理解了内存模型和可见性的基础上,就不难理解这些规则了.多线程程序要正确执行,首先要满足可见性,其实要满足原子性,可见性使得操作的数据是最新的,而原子性保证操作的过程不会因为线程对数据的同时更新而导致错误结果.在本地内存中数据对线程都是可见的,但由于操作的顺序问题,也可能导致数据不准确,比如a=a+1这个操作就不是原子操作,它实际包含读取a,设置a=a+1,写入a三个操作,这样两个线程同时执行,可能由于顺序问题而导致a的值只更新了1次.总结起来,多线程下数据的正确性=可见性+原子性.只有同时满足这两点,程序才能执行正确.原子性主要靠锁或者CAS等操作来保护(这里的主题不是这个),可见性就靠java制定的一些规则来保护,比如Happen Before.</p><p>Happen Before中的一些规则,无非就是要保证可见性,在我看来,无非就是要保证数据被及时刷新到本地内存中.上面讲解的volatile其实就具备了这样的特性,比如:对volatile修饰的值的写入操作在下一次读取时总能读到正确的值.在Java并发编程实战一书中,这个规则被描述成:对volatile变量的写入操作必须在对该变量的读操作之前执行.我不知道这个是翻译问题还是什么问题,总觉得描述得很奇怪,为什么写入一定在读之前,我可以读两次再写不行吗?我的理解是说要保证读写的可见性即可,爱怎么读就怎么读!</p><p>再举一个Happen Before规则,即进入一个同步块总能从本地内存读取到线程可见的变量的最新值,退出一个同步块总能写入变量的最新值到本地内存中.这个同步块所具备的效果,不就是volatile所具备的效果吗?再加上同步代码块能保证程序是同步执行的,所以所保护的代码段就一定不会出问题,即满足了可见性和原子性两个条件.至于重排序,比如在同步代码块中,在符合逻辑的情况下(比如变量有前后依赖关系就不能乱排),爱怎么排就怎么排.</p><p>Happen Before还有其他一些规则,但总结起来,感觉就是本地内存刷新和读取规则,目的就是保证数据对所有线程的可见性,不要在一些地方直接读取缓存,或者不把缓存数据写入本地内存.所以叫Happen Before总觉得很奇怪,叫可见性规则或者Java内存刷新与读取规则可能更合适.当然,这只是个人的见解.:)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>快速排序之精彩解说</title>
    <link href="http://example.com/2022/09/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%B2%BE%E5%BD%A9%E8%A7%A3%E8%AF%B4/"/>
    <id>http://example.com/2022/09/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%B2%BE%E5%BD%A9%E8%A7%A3%E8%AF%B4/</id>
    <published>2022-09-13T19:09:00.000Z</published>
    <updated>2022-09-24T16:11:45.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="故事开始了"><a href="#故事开始了" class="headerlink" title="故事开始了"></a>故事开始了</h3><p>假设有这样一个场景,有个小学生给了你10000个数字,要你在一天之内把这些数字排好序,然后交给他.身为一个程序猿,你想到了排序算法,进而又想到了快速排序.那么快速排序是怎么实现的呢?</p><p>既然10000个数字能排序,那么6个数字也能排序,只要6个数字时,运行结果是准确的,那么这个排序算法就能通用任意个数字的排序.假设我们有这么6个数字:</p><p><code>3 7 2 1 4 6</code> .首先,快速排序要找个基准点,一般是开头的数字,在我们这个例子中是3,然后想办法把3放到数列的中间位置,使得左边的数字比3小,右边的数字比3大,然后再递归3左右两边的数组,继续使用快速排序,最后就能全局排序.所以要搞清楚,有什么办法可以做到我们要的效果.一个可行的方法是这样的:在数组的头部和尾部各放置一个指针,然后让尾巴和3进行比较,如果大于等于3,那么就往左移动,如果碰到了比3大的数,那么就停下来.另外,如果碰到了左边的指针,也要停下来,这说明我们要的效果已经达到了.说这么多,可能还不够直观,我们用图的方式来模拟这个过程.</p><p>起初,整个指针的位置是这样的:</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i3sgao46j20oc084aa2.jpg" alt="截屏2022-09-24 下午11.17.26"></p><p>指针继续向左移动,6比3大,4也比3大,直到遇到了1,比3小,这个时候右边的指针就停下来,并且在移动过程中并未碰到左边的指针.现在指针的位置是这样的:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i588myc3j20lo0883yk.jpg" alt="截屏2022-09-24 下午11.20.33"></p><p>同理,左边的指针如果小于等于3,也要向右移动,直到遇到比3大的数,或者遇到了右指针也要停下来.3等于3,向右移动,7大于3,停下来,现在指针的位置是这样的:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i40saekgj20m807smx6.jpg" alt="截屏2022-09-24 下午11.23.47"></p><p>此时,我们把两个指针所指的数字交换一下,为什么要交换呢?因为我们要使得左边的数比3小,右边的数比3大,然后就形成了下面这张图:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i44cs5kpj20m0080q2x.jpg" alt="截屏2022-09-24 下午11.29.09"></p><p>此时,两个指针还未碰到,但是我们能看到的是:右指针右边的数据全部比3大,左指针左边的数字全部比3小.这是一个很直观的现象.</p><p>接着,我们继续移动右指针,这里的7还要和3再比较一次,当然肯定是比3大,所以一定会左移.然后2比3小,右指针又停下来了:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i4btxz5cj20mq08et8q.jpg" alt="截屏2022-09-24 下午11.36.04"></p><p>然后左指针用1和3比,肯定要向右移动,然后移动过去时,发现碰到了右指针:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i4e2j0k0j20m807ugll.jpg" alt="截屏2022-09-24 下午11.38.27"></p><p>它们撞到一起去了,这个时候我们已经达到了我们的目的,这就是左右指针停下来的一个标志,我们把开头的3和此时这个位置上的2进行一个交换,那么就变成了:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i4i06tv6j20lm08ijrd.jpg" alt="截屏2022-09-24 下午11.41.22"></p><p>卧槽!我们达到我们的终极目的:使得3左边的数字比3小,右边的数字比3大.</p><p>接下来的故事是,保持3这个位置不动,将左边的2,1当成一个数组,右边的7,4,6当成一个数组,然后再重新对每个数组搞两个指针进行移动,切记:<strong>撞到了就是成功了</strong>.那么我们可以使用递归的方式来做剩余的事情.如果数组只剩下一个元素,那么一定要结束递归,此时的结束条件是<code>i&gt;=j</code>.下面将展示快速排序的代码,也就是模拟我们现在的整个过程.</p><h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] nums,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span>(i&gt;=j)&#123;<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-keyword">int</span> start = i;<br>     <span class="hljs-keyword">int</span> end = j;<br>     <span class="hljs-keyword">int</span> basic = nums[i];<br>     <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>         <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; nums[j] &gt;= basic) &#123;<br>             j--;<br>         &#125;<br>         <span class="hljs-keyword">while</span>(i&lt; j &amp;&amp; nums[i] &lt;= basic) &#123;<br>             i++;<br>         &#125;<br>         <span class="hljs-keyword">if</span>(i&lt;j) &#123;<br>             ArrayUtil.swap(nums, i, j);<br>         &#125;<br>     &#125;<br>     ArrayUtil.swap(nums,i,start);<br>     quickSort(nums,start,i-<span class="hljs-number">1</span>);<br>     quickSort(nums,i+<span class="hljs-number">1</span>,end);<br> &#125;<br></code></pre></td></tr></table></figure><p>首先代码的开始是判断是不是要结束递归,紧接着,搞出两个指针,开始和开头位置的数字进行比较.代码里面始终要判断<code>i&lt;j</code>,因为<strong>撞到了就是成功了</strong>,无需再进行下去,另外再没撞到之前,如果双方都停下来一次之后,要交换一下所指的数字,这是为了确保右边的数字比开头的数字大,左边的数字比开头的数字小.</p><p>然后,如果i和j相遇,那么一次完整的快速排序就结束了,在遇到的地方和开头的数字进行一次交换,接着再进行左右两个数组的排序,如此递归下去,直到排完.</p><h3 id="故事的最后"><a href="#故事的最后" class="headerlink" title="故事的最后"></a>故事的最后</h3><p>你轻轻松松的排完了10000个数字,写下代码的过程只用了59秒,接着你拿起了桌上那瓶95年的可乐喝了一口,顺手掏出了手机,开始刷起了你养了多年的B站号,进入了传说中的<strong>工作休息区</strong>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka的ack机制</title>
    <link href="http://example.com/2021/07/08/Kafka%E7%9A%84ack%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/07/08/Kafka%E7%9A%84ack%E6%9C%BA%E5%88%B6/</id>
    <published>2021-07-07T16:58:31.000Z</published>
    <updated>2021-07-07T17:09:18.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kafka的ack机制"><a href="#Kafka的ack机制" class="headerlink" title="Kafka的ack机制"></a>Kafka的ack机制</h2><p>在博客中有一篇关于Kafka消息丢失和消息重复的文章,已经有对ack进行了讨论,这里再把这个概念拿出来单独说说.</p><p>Kafka的ack机制实际上指的是生产者的ack配置,不同的配置对消息的处理方式不同,配置得越严格消息越不容易丢失,主要有以下几种配置:</p><ul><li><p><code>ack=0</code>,消息一旦发送出去,就认为是发送成功了,即使Broker没有接收到消息.</p></li><li><p><code>ack=1</code>,一旦首领接收到消息,那么会收到发送成功的响应.但是首领有可能在消息同步到其它副本前发生崩溃,其它副本成为新的首领(即使禁用了不完全的首领选举),所以这个配置还是有可能导致消息丢失的.</p></li><li><p><code>ack=all</code>,这里的all等于Broker端配置的<code>min.insync.replicas</code>的个数,如果有等于这个个数的副本接收到消息,才能收到成功响应,但是要保证消息不可能丢失,应该是要保证所有副本都能收到消息,所以要使得<code>min.insync.replicas</code>等于副本个数.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Kafka消息丢失和消息重复,解决方案</title>
    <link href="http://example.com/2021/06/30/Kafka%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D/"/>
    <id>http://example.com/2021/06/30/Kafka%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D/</id>
    <published>2021-06-30T07:17:00.000Z</published>
    <updated>2021-07-07T16:50:47.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kafka什么时候出现消息丢失和消息重复-解决方案"><a href="#Kafka什么时候出现消息丢失和消息重复-解决方案" class="headerlink" title="Kafka什么时候出现消息丢失和消息重复,解决方案"></a>Kafka什么时候出现消息丢失和消息重复,解决方案</h2><p>消息队列的参与者无非是三个:生产者、Broker以及消费者.消息丢失和消息重复在这三个参与者当中都会出现,本篇文章以这三者的角度来叙述消息丢失和消息重复问题.</p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><h4 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h4><p>如果生产者往Broker发送消息,没有等到Broker的回复,就认为是成功了,那么就可能存在生产者的消息丢失.可能由于网络原因导致消息没有到达Broker或是其它一些异常情况.生产者发送消息有一个发送确认的概念,使用<code>ack</code>来进行配置.</p><ul><li>当设置<code>ack=0</code>时,消息一旦从生产者端发送出去就认为是成功了.这种情况就很有可能出现消息丢失.</li><li>当设置<code>ack=1</code>时,会等到首领收到消息,并返回结果才算是发送成功.这种情况认为生产者已经发送成功了,对于生产者端来说不会出现消息丢失,而对于Broker来说可能存在消息丢失,主要和同步副本有关系,这个将在下面讲解.</li><li>当设置<code>ack=all</code>时,会等到首领及首领配置的最小同步副本都接收到消息,那么才算是发送成功,Broker通过<code>min.insync.replics</code>来进行配置,比如这个属性配置成2,那么要至少有2个Broker接收到消息才算成功,不会出现消息丢失,除此之外更加严格的确保消息在副本之间的一致性.</li></ul><p>所以如果要让消息不丢失,那么可以设置ack=1或者ack=all.</p><h4 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h4><p>消息重复是无法避免的情况,即使消息真正存放到Broker之中,Broker返回的响应结果也有可能由于网络原因出现丢失或者超时的可能性.这个时候生产者误以为自己没有发送成功,那么就有可能会重试发送消息,Broker再次接收到消息,那么消息就发生了重复.</p><p>这种消息重复只能在Broker端或者消费者端做逻辑上的去重处理.</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><h4 id="消息丢失-1"><a href="#消息丢失-1" class="headerlink" title="消息丢失"></a>消息丢失</h4><p>在Broker端存在三个很重要的概念:复制系数,不完全的首领选举及最小同步副本.</p><h5 id="复制系数"><a href="#复制系数" class="headerlink" title="复制系数"></a>复制系数</h5><p>复制系数表示一个分区有多少个副本,通过<code>replication.factor</code>来进行配置,很明显这个值配置得越大,消息越不容易丢失,但是复制带来的性能损耗也越大.</p><h5 id="不完全的首领选举"><a href="#不完全的首领选举" class="headerlink" title="不完全的首领选举"></a>不完全的首领选举</h5><p>不完全的首领选举表示在进行首领选举时,是否允许非同步副本成为首领,一般通过<code>unclean.leader.election</code>进行配置,如果配置成<code>true</code>,那么可能出现首领宕机,但其它副本并没有同步完成时成为新的首领,那么就可能出现消息丢失.如果配置成<code>false</code>,那么分区在旧首领重启之前就是不可用的,这种情况不会出现消息丢失.</p><p>但是可能出现这么一种情况,消息写入到首领之后,还没有同步到其它副本中,此时首领宕机了,但是其它副本还是认为自己是同步的,还是会进行首领选举产生新首领,所以使用这个配置并不能完全防止消息丢失,只能认为它具有一定的防止消息丢失的作用.</p><h5 id="最小同步副本"><a href="#最小同步副本" class="headerlink" title="最小同步副本"></a>最小同步副本</h5><p>最小同步副本是在Broker端对消息同步副本个数的约束,一般通过<code>min.insync.replicas</code>进行配置.比如配置成2,那么要保证至少有两个同步副本时分区才能对外进行写服务,否则只能提供读服务,将最小同步副本设置成分区副本的总个数,那么在Broker端就不会出现消息丢失.</p><p>所以要让消息不丢失,可以禁用不完全的首领并且或者并且最小同步副本个数为分区副本个数.</p><h4 id="消息重复-1"><a href="#消息重复-1" class="headerlink" title="消息重复"></a>消息重复</h4><p>在Broker端出现消息重复的根本原因是生产者重复发送导致的.对于Broker来说,可以根据Broker本身提供的幂等功能来进行去重.</p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><h4 id="消息丢失-2"><a href="#消息丢失-2" class="headerlink" title="消息丢失"></a>消息丢失</h4><p>消费者一般通过轮询的方式来获取消息,消息消费成功后就提交偏移量.如果消费者没有消费成功,但是提交了偏移量,那么就存在消息丢失的可能性,下一次拉取的消息就不会有本次消费失败的消息.</p><p>对于这种情况,要确保消息处理成功再提交偏移量,或者对于没有处理成功的消息,保存到数据库或者缓存中,稍后再进行处理.</p><h4 id="消息重复-2"><a href="#消息重复-2" class="headerlink" title="消息重复"></a>消息重复</h4><p>消费者如果没有成功提交偏移量或者提交了已处理成功的消息的偏移量,那么就有可能导致消息重复.对于这种情况,要确保消息处理和偏移量提交的原子性(将偏移量作为数据库表的列,通过事务处理),或者在处理消息前判断数据库中是否已经有该消息对应的记录.</p><p>除此之外,如果Broker没有对重复的消息进行去重,消费者也置之不理,那么也会出现消息重复.对于这种情况,要根据业务标识做幂等处理.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper节点类型及特点</title>
    <link href="http://example.com/2021/06/30/Zookeeper%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9/"/>
    <id>http://example.com/2021/06/30/Zookeeper%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9/</id>
    <published>2021-06-29T17:35:00.000Z</published>
    <updated>2021-06-30T09:34:17.850Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Zookeeper节点类型及特点"><a href="#Zookeeper节点类型及特点" class="headerlink" title="Zookeeper节点类型及特点"></a>Zookeeper节点类型及特点</h2><p>Zookeeper共有四种节点类型:</p><ul><li><p>持久节点.持久节点指的是在Zookeeper上进行持久化的节点,除非主动进行删除,否则节点会一直存在.</p></li><li><p>持久顺序节点.在持久节点的基础上,添加了顺序.比如创建一个持久节点,那么会自动的在路径的末尾添加一个序列号.比如连续创建两次/A/B,并表示创建的是顺序节点,那么会创建<code>/A/B0000000000</code>和<code>/A/B0000000001</code>这两个持久顺序节点,如果创建的是/A/C,那么会创建<code>/A/C0000000002</code>,这是因为有一个父节点在维护这些顺序节点的顺序(从0开始递增),只要是创建带有顺序的子节点,都会使用这个顺序来作为节点的后缀.</p></li><li><p>临时节点.临时节点指的是会话结束后会被删除的节点.临时节点不能有子节点,所以临时节点一定是叶子节点.</p></li><li><p>临时顺序节点.在临时节点的基础上,添加了顺序,其创建出来的节点路径规律和持久顺序节点是类似的.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="zookeeper" scheme="http://example.com/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://example.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>CAP定理</title>
    <link href="http://example.com/2021/06/29/CAP%E5%AE%9A%E7%90%86/"/>
    <id>http://example.com/2021/06/29/CAP%E5%AE%9A%E7%90%86/</id>
    <published>2021-06-29T08:36:00.000Z</published>
    <updated>2021-06-30T09:34:05.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>CAP定理指的是在分布式环境中,只可能满足一致性、可用性、分区容错性中的其中两个,不可以三个都满足.</p><p>一致性:这里的一致性指的是强一致性,如果节点有副本,那么一旦一个节点的数据进行更新之后,那么在另外一个节点能立即获取到更新后的值.</p><p>可用性:可用性指的是在有限的时间返回正确的结果.对于不同系统来说,有限的时间是根据具体的应用场景来定义的一个合理的指标,比如对于搜索引擎而言,这个有限的时间就是一个比较短暂的时间,比如100ms.对于一个离线处理任务来说,可能长达几分钟或者几个小时.正确的结果是一个对用户来说看的懂或者说有意义的结果,比如下单成功或失败,而不是<code>NullPointer Exception</code>这种结果.</p><p>分区容错性:网络分区指的是两个网络之间由于网络问题,导致不同节点无法进行通信,各自形成一个子网络.分区容错性指的是即使出现网络分区,系统也能提供具有一致性和可用性的服务.</p><p>因为是在分布式环境下,那么网络分区是一个必然会出现的问题,所以在设计系统时,一般考虑的是系统的一致性和可用性.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式环境中的问题</title>
    <link href="http://example.com/2021/06/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/06/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-29T08:24:00.000Z</published>
    <updated>2021-06-29T08:36:11.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分布式环境中的问题"><a href="#分布式环境中的问题" class="headerlink" title="分布式环境中的问题"></a>分布式环境中的问题</h2><p>现在几乎所有的软件都是分布式环境,那么分布式环境有什么问题呢?</p><ul><li><p>通信问题.如果是单体应用,那么所有的程序逻辑都会在一台机器上进行处理,一般不会出现网络通信问题.但是在分布式环境,会涉及到不同机器之间的通信,所以可能会出现类似网络丢包等问题.</p></li><li><p>机器故障.故障一般指的是机器宕机或者僵死.如果是单体应用,那么故障之后会造成服务不可用,重启之后又可以继续进行服务.在分布式环境下,故障问题就可能发生在所有的机器上.</p></li><li><p>网络分区.在分布式环境中,机器可能部署在不同的网络环境中,有可能出现机器本身运行正常但网络出现分区的情况,即两个网络之间的通信链路出现了问题.</p></li><li><p>三态问题.如果是单体应用,那么一般来说一个请求的处理结果要么是成功或者失败.如果是分布式环境,那么可能由于网络原因出现第三种处理结果-超时.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper和Redis实现分布式锁的区别</title>
    <link href="http://example.com/2021/06/29/Zookeeper%E5%92%8CKafka%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/29/Zookeeper%E5%92%8CKafka%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-29T03:23:00.000Z</published>
    <updated>2021-06-29T03:34:27.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Zookeeper和Redis实现分布式锁的区别"><a href="#Zookeeper和Redis实现分布式锁的区别" class="headerlink" title="Zookeeper和Redis实现分布式锁的区别"></a>Zookeeper和Redis实现分布式锁的区别</h2><p>在网上看了关于Zookeeper和Redis实现分布式锁的区别的一些文章,感觉可能有的文章写的这两者的区别可能跟我的理解有点出入,所以这里按照自己的理解来谈谈它们的区别:</p><ul><li><p>Zookeeper实现分布式锁时,除了可以使用和redis类似的独占锁的思路,还可以监听节点变更事件,在锁可能可以获取到的情况下通知客户端再次获取锁.</p></li><li><p>Redis在获取锁时,可能需要设置过期时间,而Zookeeper通常是设置一个临时节点,在会话过期的时候自动释放锁.</p></li></ul><p>还有一些其它区别暂时还没有学习到,可能是一些算法设计或者一致性方面的内容,如果以后涉及到这部分内容,再进行补充.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://example.com/2021/06/25/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/06/25/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-25T11:49:00.000Z</published>
    <updated>2021-06-25T12:01:22.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式解决的是一种关于发布/订阅的场景,是观察者和通知者的一种交互方式.举个例子:现在很流行订阅APP的消息,那么APP就相当于通知者,我们的手机相当于观察者,当APP有消息要发布时,会遍历所有它的观察者进行消息的发送.在实际编码中,我们在描述这种关系时可能要注意将观察者抽象化,或者将通知者抽象化,如果不抽象化我们也能描述这种发布/订阅的关系,只不过代码的扩展性比较差.</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><a href="https://github.com/CodeShowZz/code-repository/tree/master/design-pattern-demo/src/main/java/com/observer">https://github.com/CodeShowZz/code-repository/tree/master/design-pattern-demo/src/main/java/com/observer</a></p><p>这里有一个简单的代码示例,将观察者和通知者进行了一定的抽象,实际应用场景中可以是使用接口进行抽象,或者使用抽象类进行抽象,总之就是代码的具体实现可能是多种多样的,重要的事情在于要把模式体现出来和要使程序具有扩展性即可,不能拘泥于某种代码写法.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2021/06/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/06/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-25T09:11:00.000Z</published>
    <updated>2021-06-25T10:26:32.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是最简单的设计模式,它用来解决一个类只可以有一个唯一实例的问题,该类提供一个访问该实例的方法.单例模式需要注意的一个点是要保证在多线程的环境下,也能保证单例.</p><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><p>如果我们在需要单例的情况再去初始化它,则叫做懒汉式单例.</p><p>通常我们会这么写一个单例模式:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Singleton <span class="hljs-function"><span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        synchronized (Singleton.class) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">singleton == <span class="hljs-literal">null</span></span>)</span> &#123;<br>                singleton = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这么做有一个坏处,就是每次都会有锁的开销,进而有人发明了双重检查的写法:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton2</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton2</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Singleton2 <span class="hljs-function"><span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">singleton ==<span class="hljs-literal">null</span></span>)</span> &#123;<br>            synchronized (Singleton2.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> Singleton2();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种写法是有问题的,这里主要的问题在于可见性问题,有可能A线程执行了new操作,但是对象没有完全被构建,B线程获取到了这个没有完全被构建完成的对象,这样是不安全的.进而有大神发明了一个更牛逼的写法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingletonFactory</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Singleton3 <span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.singleton3;<br>    &#125;<br>    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 singleton3 = <span class="hljs-keyword">new</span> Singleton3();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton3</span> &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton3</span>(<span class="hljs-params"></span>)</span> &#123;<br>           <br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法能做到懒加载方式,又能保证线程安全,堪称单例模式的最佳写法.</p><h3 id="恶汉式"><a href="#恶汉式" class="headerlink" title="恶汉式"></a>恶汉式</h3><p>如果我们在程序的初始阶段就实例化单例,则叫做恶汉式单例.</p><p>写法也是简单粗暴:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton4</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Singleton4 singleton = <span class="hljs-keyword">new</span> Singleton4();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton4</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Singleton4 <span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac Os Open JDK编译</title>
    <link href="http://example.com/2021/06/25/Mac%20Os%20Open%20JDK%E7%BC%96%E8%AF%91/"/>
    <id>http://example.com/2021/06/25/Mac%20Os%20Open%20JDK%E7%BC%96%E8%AF%91/</id>
    <published>2021-06-25T03:47:00.000Z</published>
    <updated>2021-06-29T07:33:34.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Open-JDK编译"><a href="#Open-JDK编译" class="headerlink" title="Open JDK编译"></a>Open JDK编译</h2><p>我们经常都会看一些源码,但有没有想过动手修改源代码呢?在平时的开发环境中,是无法直接修改源码的,如果要修改源码,那么就要获取源代码进行编译,想象一下我们可以修改源码,然后在看源码的时候加上一些注释,仿佛成为JDK的开发人员那样,是不是很有意思?编译JDK是一个比较繁琐的过程,这里以Mac OS系统为例.</p><h3 id="第一步-下载Open-JDK11"><a href="#第一步-下载Open-JDK11" class="headerlink" title="第一步:下载Open JDK11"></a>第一步:下载Open JDK11</h3><ol><li><p>进入页面 <a href="https://adoptopenjdk.net/installation.html?variant=openjdk11&jvmVariant=hotspot#x64_mac-jdk">https://adoptopenjdk.net/installation.html?variant=openjdk11&amp;jvmVariant=hotspot#x64_mac-jdk</a> 下载 tar.gz 包</p></li><li><p>解压到/Library/Java/JavaVirtualMachines,如果你有其它版本的JDK则不需要设置环境变量,否则需要设置.</p></li></ol><h3 id="第二步-下载XCode"><a href="#第二步-下载XCode" class="headerlink" title="第二步:下载XCode"></a>第二步:下载XCode</h3><p>编译过程需要使用到XCode.在我的系统里面,App Store的XCode版本并不兼容我的系统,所以要找到兼容本系统的历史版本进行下载.可以在<a href="https://developer.apple.com/download/all/?q=Xcode%2011.7">https://developer.apple.com/download/all/?q=Xcode%2011.7</a>下载.</p><p><img src="/images/open_jdk_01.png" alt="xcode历史版本查看"></p><h3 id="第三步-下载Open-JDK11源码"><a href="#第三步-下载Open-JDK11源码" class="headerlink" title="第三步:下载Open JDK11源码"></a>第三步:下载Open JDK11源码</h3><p>在<a href="http://hg.openjdk.java.net/jdk-updates/jdk11u/">http://hg.openjdk.java.net/jdk-updates/jdk11u/</a>下载zip包,解压到一个英文目录中.</p><h3 id="第四步-编译"><a href="#第四步-编译" class="headerlink" title="第四步:编译"></a>第四步:编译</h3><p>进入到下载的jdk源码目录中,使用命令<code>sh configure --with-target-bits=64 --enable-ccache --with-jvm-variants=server  --with-boot-jdk-jvmargs=&quot;-Xlint:deprecation -Xlint:unchecked&quot; --disable-warnings-as-errors --with-debug-level=slowdebug 2&gt;&amp;1 | tee configure_mac_x64.log </code>进行编译.</p><p>在我的实际编译中,遇到了这样一个错误:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">configure: error: <span class="hljs-literal">No</span> xcodebuild<span class="hljs-built_in"> tool </span><span class="hljs-keyword">and</span> <span class="hljs-literal">no</span><span class="hljs-built_in"> system </span>framework headers found, use --with-sysroot <span class="hljs-keyword">or</span> --with-sdk-name <span class="hljs-keyword">to</span> provide a path <span class="hljs-keyword">to</span> a valid SDK<br>/Users/huangjunlin/IdeaProjects/jdk11u-113c646a33d2/build/.configure-support/generated-configure.sh: line 82: 5: Bad file descriptor<br></code></pre></td></tr></table></figure><p>此时应执行<code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer</code>后再运行上面的命令.如果编译成功,将出现类似如下代码输出:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Build performance summary:</span><br><span class="hljs-string">*</span> <span class="hljs-attr">Cores to use:</span>   <span class="hljs-number">4</span><br><span class="hljs-string">*</span> <span class="hljs-attr">Memory limit:</span>   <span class="hljs-number">8192 </span><span class="hljs-string">MB</span><br><span class="hljs-string">*</span> <span class="hljs-attr">ccache status:</span>  <span class="hljs-string">Active</span> <span class="hljs-string">(3.7.1)</span><br></code></pre></td></tr></table></figure><p>之后在这个目录使用<code>make</code>命令进行编译,整个过程可能会耗费一定时间,如果执行命令有问题,记得先加上<code>sudo</code>进行尝试,还有就是如果卡在某个地方,请耐心等待,大部分情况最终都会向下执行的,不要一开始就认为它挂了.等到出现</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">Finished building <span class="hljs-keyword">target</span> <span class="hljs-string">&#x27;default (exploded-image)&#x27;</span> in configuration <span class="hljs-string">&#x27;macosx-x86_64-normal-server-slowdebug&#x27;</span><br></code></pre></td></tr></table></figure><p>在build目录出现<code>macosx-x86_64-normal-server-slowdebug/jdk</code>文件夹,那么编译就完成了.</p><h3 id="第五步-指定Idea的JDK"><a href="#第五步-指定Idea的JDK" class="headerlink" title="第五步:指定Idea的JDK"></a>第五步:指定Idea的JDK</h3><p>创建一个Idea项目,在Idea的<code>Project Structure</code>指定SDK为刚刚编译出来的jdk,路径类似为<code>/jdk11u-113c646a33d2/build/macosx-x86_64-normal-server-slowdebug/jdk</code>.</p><h3 id="第六步-下载CLion"><a href="#第六步-下载CLion" class="headerlink" title="第六步:下载CLion"></a>第六步:下载CLion</h3><p>Clion是一个C/C++的一个开发工具,我们要修改JDK的源码,可以借助这个工具来进行修改,这个工具跟Idea的风格很像,下载也很简单.下载完成之后,使用它打开<code>jdk11u-113c646a33d2/src</code>目录,我们就是在导入的文件中修改源码.</p><h3 id="第七步-修改源码并测试"><a href="#第七步-修改源码并测试" class="headerlink" title="第七步:修改源码并测试"></a>第七步:修改源码并测试</h3><p>找到<code>java.c</code>文件,添加一条输出语句,片段如下:</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-built_in">int</span><br><span class="hljs-type">JavaMain</span>(void* _args)<br>&#123;<br>    <span class="hljs-type">JavaMainArgs</span> *args = (<span class="hljs-type">JavaMainArgs</span> *)_args;<br>    printf(<span class="hljs-string">&quot;修改open jdk&quot;</span>);<br>    <span class="hljs-built_in">int</span> argc = args-&gt;argc;<br>    <span class="hljs-built_in">char</span> **argv = args-&gt;argv;<br>    <span class="hljs-built_in">int</span> mode = args-&gt;mode;<br>    <span class="hljs-built_in">char</span> *what = args-&gt;what;<br>    <span class="hljs-type">InvocationFunctions</span> ifn = args-&gt;ifn;<br></code></pre></td></tr></table></figure><p>重新运行<code>make</code>命令,进行重新编译,这次编译速度相对来说会比较快.然后在Idea用<code>main</code>方法进行测试:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>         <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果输出了<code>修改open jdk</code>;</p><p>在网上还有一些关于在Clion打断点的文章,但好像对.java上打断点没有过多的描述,我认为对看源码参考价值不大,这部分内容后续还要再研究一下.</p><p>感觉整个过程遇到了好多坑,编译JDK还是比较麻烦的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="其它" scheme="http://example.com/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>Java锁的优化</title>
    <link href="http://example.com/2021/06/24/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/06/24/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2021-06-24T11:05:00.000Z</published>
    <updated>2021-06-25T10:24:54.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java锁的优化"><a href="#Java锁的优化" class="headerlink" title="Java锁的优化"></a>Java锁的优化</h2><p>在JDK6,Java对synchronized进行了大量的改进,包括适应性自旋,锁膨胀,轻量级锁,偏向锁.</p><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><p>自旋指的是当线程获取不到锁的时候,不用直接进入挂起状态,而是执行一个忙循环,如果在忙循环结束之后能获取到锁,那么就可以减少线程切换的开销.自适应自旋通过统计自旋相关的一些参数信息,从而动态的调整执行忙循环的次数,甚至有可能跳过自旋过程.</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>如果在一个方法内部声明一个对象,并且这个对象不可能被外部的方法所访问到,但是这个对象的一些方法可能有关于锁的一些操作,这样可能会降低程序运行的性能.所以在即时编译器检查到这类操作时,会将这些关于锁操作的代码消除掉.</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>通常来说,将锁的粒度控制得小一点是一个不错的做法,但是如果某些操作,频繁的用同一个对象进行加锁和解锁,那还不如将锁的范围扩大,这就是锁粗化.</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>这部分内容还有一些疑问没有搞清楚,留待以后补充</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock和Synchronized的区别</title>
    <link href="http://example.com/2021/06/24/ReentrantLock%E5%92%8CSynchronized/"/>
    <id>http://example.com/2021/06/24/ReentrantLock%E5%92%8CSynchronized/</id>
    <published>2021-06-24T03:56:00.000Z</published>
    <updated>2021-06-25T10:24:28.976Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h2><p>有了Synchronized,为什么还要有ReentrantLock呢?这是因为在某些特定的场景,Synchronized无法提供很好的灵活性,而ReentrantLock提供了一些更高级的功能,但是同时也有一些缺点.</p><p>两者主要的区别如下:</p><ul><li>ReentrantLock可以在获取锁失败时立即退出或者在一段时间内等待锁的获取,可以防止锁顺序死锁,而Synchronized不能.</li><li>ReentrantLock可以在等待获取锁的时候响应中断,而Synchronized不能.</li><li>ReentrantLock要手动释放锁,而Synchronized能自动释放锁.</li><li>在JDK5时,ReentrantLock的性能比Synchronized好.从JDK6开始,两者性能差不多.</li><li>Synchronized是非公平锁,ReentrantLock既可以是公平锁,也可以是非公平锁.</li></ul><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>应该优先考虑使用Synchronized,因为它能够自动释放锁,这样能降低危险性.只有在需要一些高级功能时,才应该考虑ReentrantLock.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域</title>
    <link href="http://example.com/2021/06/24/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <id>http://example.com/2021/06/24/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-06-24T03:09:00.000Z</published>
    <updated>2021-06-25T12:10:23.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JVM运行时数据区域"><a href="#JVM运行时数据区域" class="headerlink" title="JVM运行时数据区域"></a>JVM运行时数据区域</h2><p>JVM运行时数据区域如下图所示:</p><p><img src="/images/jvm_runtime_area_01.png" alt="JVM运行时数据区域"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是线程私有的,指向当前线程执行的字节码行号,当线程挂起后恢复,就是通过这个计数器来知道下一条指令的执行位置.</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈是线程私有的,在方法执行的时候,会在线程中创建一个栈帧,存放局部变量表、操作数栈、动态连接、方法出口等信息,每个方法的调用到执行完毕对应栈帧的入栈和出栈过程.</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈是线程私有的,和Java虚拟机栈相似,区别在于它为Native方法服务.</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>堆是线程共享的,几乎所有的对象实例都是分配在Java堆上,另外从JDK7开始,本位于方法区的字符串常量池已经移动到了堆上.</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是线程共享的,用来存放虚拟机加载的类型信息.运行时常量池是方法区的一部分,编译期生成的各种字面量和符号引用在类加载后会存放到运行时常量池中.</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>这部分区域并不属于JVM运行时数据区域,但是JAVA里的部分技术可能使用到这部分内存,如NIO,通过Native函数库直接分配堆外内存,所以在使用时要考虑本机总内存的大小.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="http://example.com/2021/06/24/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://example.com/2021/06/24/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2021-06-23T16:34:00.000Z</published>
    <updated>2021-06-23T18:24:21.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h2><p>JVM垃圾收集器中比较经典的收集器如下图所示:</p><p><img src="/images/jvm_collectors_01.jpg" alt="jvm经典垃圾收集器"></p><p>从图中可以看到,经典垃圾收集器目前有7种,图片米色部分的是新生代收集器,浅绿色部分是老年代收集器,横跨两种颜色的G1既是新生代收集器又是老年代收集器.除了这几个收集器之外,还有一些新版本的低延迟垃圾收集器,比如Shenandoah和ZGC收集器.接下来介绍一下各个收集器.</p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>Serial是新生代垃圾收集器,具有如下特点:</p><ul><li>采取标记复制算法进行垃圾回收</li><li>垃圾回收过程会暂停用户线程,并使用单个线程对垃圾进行回收</li></ul><p>Serial是串行的意思,名字很好的反映了该收集器的特点.</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>Serial Old是老年代垃圾收集器,具有如下特点:</p><ul><li>采取标记整理算法进行垃圾回收</li><li>垃圾回收过程会暂停用户线程,并使用单个线程对垃圾进行回收</li></ul><p>和上面的Serial收集器对比,该收集器不同的点就是工作在老年代,垃圾回收的算法不一样.</p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>从名字中的New可以看出来这是一个新生代垃圾收集器,而名字中的Par代表的意思是并行,代表该收集器会同时开启多个线程来进行垃圾回收,所以可以把它认为是Serial收集器的并行回收版本,特点如下:</p><ul><li>采取标记复制算法进行垃圾回收</li><li>垃圾回收过程会暂停用户线程,并使用多个线程对垃圾进行回收</li></ul><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>这个收集器也是新生代收集器,其基本特点与ParNew一模一样,除此之外,还有其它特别之处,可以理解为ParNew的加强版.除了ParNew的两个特点之外,特别之处在于这是一个关注吞吐量的收集器,它可以设定两个参数来控制垃圾收集器的吞吐量.首先<code>吞吐量 = 运行用户代码时间/(运行用户代码时间+运行垃圾收集时间.)</code>第一个参数<code>-XX:MaxGCPauseMillis</code>来让垃圾收集器尽可能保证垃圾收集的停顿时间小于这个指定的时间.第二个参数<code>-XX:GCTimeRatio</code>指定了GC时间占垃圾回收时间的比值,计算方式为<code>GC占用时间比例=1/1+指定的值)</code>.除此之外,该收集器还提供了<code>-XX:UseAdaptiveSizePolicy</code>参数来根据运行情况收集性能信息来调整垃圾收集器的参数,这个叫做自适应调节策略.</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>从Old可以看出这是一个老年代收集器,其特点和Parallel Scavenge是一样的,不同之处在于它采用了标记整理算法来对老年代进行收集.</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS是老年代收集器,是以低停顿为目标的垃圾收集器,采用标记清除算法来清除垃圾,运行过程如下:</p><ol><li>初始标记,标记GC Roots能直接关联到的对象,这个过程需要停顿用户线程.</li><li>并发标记,遍历整个对象图来标记能回收的对象,这个过程可以和用户线程一起并发执行</li><li>重新标记,这个过程标记的是在并发标记时产生的新的垃圾,相当于做一个修正,这个过程需要停顿用户线程</li><li>并发清除,这个过程清理标记了的对象,可以与用户线程一起并发执行.</li></ol><p>CMS被称为低停顿并发收集器,在上面耗时比较长的2和4过程中可以做到和用户线程一起执行,在耗时比较短的1和3过程需要停顿用户线程,总体来说可以认为整个过程是和用户线程一起并发执行,其思想是非常优秀的.但是由于这种设计,也有如下几个缺点:</p><ul><li><p>占用CPU资源.因为与用户线程一起并发执行,那么肯定会和用户线程一起抢占CPU的执行权,这样就会导致用户线程的吞吐量下降,尤其是在CPU核心数较少的情况下.</p></li><li><p>无法处理浮动垃圾.因为在垃圾清除阶段,用户线程还在运行,这个时候老年代可能会产生新的对象,如果这个时候无法找到足够的内存空间进行对象的分配,将会出现Concurrent Mode Failure,此时将会停顿用户线程,改用Serial Old垃圾收集器来进行垃圾回收,这样停顿的时间就更长了.默认情况下,CMS会预留一部分内存空间来分配新对象,可以通过参数<code>-XX:CMSInitiatingOccupancyFraction</code>来指定占用内存的比例为多少时触发CMS的垃圾回收.</p></li><li><p>内存碎片导致无法分配新对象.因为CMS是基于标记清除的垃圾收集器,这会导致它产生大量的内存碎片,可能导致无法找到一块内存去分配新的对象,那么就很容易导致触发FULL GC.所以CMS提供了一个<code>CompactAtFullCollection</code>参数来使得进行Full GC前先进行内存碎片的整理,尝试去找到一块空间来分配新对象,但是这个过程需要移动对象,所以会停顿用户线程.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>count(*),count(1),count(column name)的区别</title>
    <link href="http://example.com/2021/06/23/count-count-1-count-column-name-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/23/count-count-1-count-column-name-%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-23T08:56:00.000Z</published>
    <updated>2021-06-23T16:12:37.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="count-count-1-count-column-name-的区别"><a href="#count-count-1-count-column-name-的区别" class="headerlink" title="count(*),count(1),count(column name)的区别"></a>count(*),count(1),count(column name)的区别</h2><h3 id="count-vs-count-1"><a href="#count-vs-count-1" class="headerlink" title="count(*) vs count(1)"></a>count(*) vs count(1)</h3><p><code>count(*)</code>和<code>count(1)</code>的功能还有性能是差不多的,这里面括号里面的参数只是一个标识符,如果发现有一行数据,那么就分配一个标识符,最后看有多少标识符而已.<code>count(1)</code>并不是说统计第一行的数据有多少个,<code>count(*)</code>也不是说要把一行的所有列都扫描一遍.如果你不信,你可以试试<code>count(-13)</code>,难道它统计的是-13列的个数?</p><p>那么它们具体是怎么去计算有多少条数据的呢?在只有主键索引的情况下,通过主键索引中索引的个数来计算有多少条数据.在有二级索引的情况下,通过二级索引中索引的个数来计算有多少条数据,如果有多个二级索引,用索引空间占用量小的二级索引来进行计算.</p><h3 id="count-vs-count-column-name"><a href="#count-vs-count-column-name" class="headerlink" title="count(*) vs count(column name)"></a>count(*) vs count(column name)</h3><p><code>count(*)</code>和<code>count(column name)</code>的区别在于<code>count(column name)</code>统计的是某一列字段的个数,其中字段值为NULL的不进行统计.</p><p>那么<code>count(column name)</code>是如何计算有多少条数据的呢?如果有<code>column name</code>对应的二级索引,那么就计算该二级索引的个数(字段值不为NULL).如果没有对应的二级索引,则扫描主键索引,通过判断行数据对应的<code>column name</code>是否为空来进行统计.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ消息重投和消息重试</title>
    <link href="http://example.com/2021/06/23/RocketMQ%E6%B6%88%E6%81%AF%E9%87%8D%E6%8A%95%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/"/>
    <id>http://example.com/2021/06/23/RocketMQ%E6%B6%88%E6%81%AF%E9%87%8D%E6%8A%95%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/</id>
    <published>2021-06-22T17:10:00.000Z</published>
    <updated>2021-06-23T16:34:38.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="RocketMQ消息重投和消息重试"><a href="#RocketMQ消息重投和消息重试" class="headerlink" title="RocketMQ消息重投和消息重试"></a>RocketMQ消息重投和消息重试</h2><h3 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h3><p>消息重投指的是生产者发送消息到Broker没有成功,然后进行重新发送.使用同步发送方式,当消息发送失败时,默认最多会重试两次,并且重试时会选择不同的Broker来进行消息的发送.</p><h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>消息重试指的是消费者在消费消息时失败,然后重新消费消息.每个消费组都有一个Topic名称为“%RETRY%+consumerGroup”的重试队列,当消息消费失败时,将根据具体的重试级别来进行重试,默认是重试16次,并且每次的重试时间间隔逐步递增.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="rocketmq" scheme="http://example.com/categories/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://example.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>怎么保证RocketMQ消息不丢失</title>
    <link href="http://example.com/2021/06/21/%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81RocketMQ%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <id>http://example.com/2021/06/21/%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81RocketMQ%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</id>
    <published>2021-06-21T05:47:00.000Z</published>
    <updated>2021-06-21T06:02:29.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="怎么保证RocketMQ消息不丢失"><a href="#怎么保证RocketMQ消息不丢失" class="headerlink" title="怎么保证RocketMQ消息不丢失"></a>怎么保证RocketMQ消息不丢失</h2><p>要保证RocketMQ消息不丢失,需要生产者、Broker以及消费者的配合.</p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者在发送消息时,如果没有收到服务器的成功响应,那么就要重试发送消息,直到消息发送成功.</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>Broker要做的事情是保证消息不丢失,当接收到生产者发送的消息时,Broker为了保证消息不丢失,会将数据同步到磁盘中,为了做到真正意义上的不丢失,需要Broker设置同步刷盘模式,必须要等到数据真的同步到磁盘上之后,再向客户端返回消息发送成功状态.</p><p>除此之外,为了提高服务的可用性,Broker通常会采用主从模式,这个时候还要保证消息真正同步到了从服务器上,需要设置主从服务器复制策略为同步复制模式,等到所有的从服务器都真正接收到数据并存储到磁盘时,再向客户端返回消息发送成功状态.</p><p>总结起来就是两点:</p><ul><li>Master保证数据同步到磁盘</li><li>Slava保证数据同步到磁盘</li></ul><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>对于消费者而言,消息不丢失意味着能够成功消费到所有消息.正常情况下,消费者成功消费之后,再向Broker返回成功消费信息,否则返回消费失败信息,使得下次还能够重新消费那些没有消费成功的消息.</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>为了保证消息不丢失,需要使用大量的同步策略,这样可能导致效率的低下,所以在实际生产环境中还需要结合实际业务进行权衡.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="rocketmq" scheme="http://example.com/categories/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://example.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>Kafka和RocketMQ的区别</title>
    <link href="http://example.com/2021/06/21/Kafka%E5%92%8CRocketMQ%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/21/Kafka%E5%92%8CRocketMQ%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-21T04:56:00.000Z</published>
    <updated>2021-06-21T05:40:02.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kafka和RocketMQ的区别"><a href="#Kafka和RocketMQ的区别" class="headerlink" title="Kafka和RocketMQ的区别"></a>Kafka和RocketMQ的区别</h2><table><thead><tr><th align="center"></th><th align="center">RocketMQ</th><th align="center">Kafka</th></tr></thead><tbody><tr><td align="center">协议和规范</td><td align="center">拉取模式,支持TCP、JMS、OpenMessage</td><td align="center">拉取模式,支持TCP</td></tr><tr><td align="center">消息顺序</td><td align="center">保证严格的消息顺序,并且可以优雅扩展</td><td align="center">保证分区消息顺序</td></tr><tr><td align="center">批量消息</td><td align="center">支持,使用同步模式来避免消息丢失</td><td align="center">支持,使用异步生产者</td></tr><tr><td align="center">广播消息</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">消息过滤</td><td align="center">支持,使用基于SQL92的属性过滤表达式</td><td align="center">支持,使用Kafka Stream过滤消息</td></tr><tr><td align="center">服务端触发重新发送消息</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">消息追溯</td><td align="center">支持偏移量和时间戳指定</td><td align="center">支持偏移量指定</td></tr><tr><td align="center">高可用</td><td align="center">使用主从模式</td><td align="center">使用Zookeeper</td></tr><tr><td align="center">消息追踪</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">服务端重新发送消息</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="rocketmq" scheme="http://example.com/categories/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://example.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="http://example.com/2021/06/21/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2021/06/21/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-06-21T03:16:00.000Z</published>
    <updated>2021-06-21T04:23:12.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><p>分布式锁主要用来解决分布式环境下资源的互斥访问,这篇文章就来介绍一下分布式锁.</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>首先要保证获取锁和释放锁的正确性,通常来说就是保证获取锁和释放锁的原子性,一般会使用<code>SETNX key 唯一标识</code>命令来获取锁,在Lua脚本中通过唯一标识来释放锁,这样能保证获取锁和释放锁的客户端是同一个.</p><h3 id="考虑宕机"><a href="#考虑宕机" class="headerlink" title="考虑宕机"></a>考虑宕机</h3><p>当客户端服务获取到锁之后挂掉了,那么锁可能永远都没办法被另外的客户端获取到,所以此时要考虑给锁加一个过期时间,保证客户端服务挂掉之后锁也能释放,通常使用<code>SETNXEXPIRE key 唯一标识 过期时间</code>来实现.</p><h3 id="考虑可用性"><a href="#考虑可用性" class="headerlink" title="考虑可用性"></a>考虑可用性</h3><p>假如我们的Redis实例只有一个,那么有可能Redis实例挂了,那么分布式锁服务就不可用了,所以我们现在要想办法提高可用性.一个比较可靠的方式是使用RedLock算法.</p><h4 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h4><p>假设我们有5个Redis实例,彼此是独立的,那么RedLock的算法的运作过程如下:</p><ol><li><p>向各个Redis实例获取锁(<code>SETNXEXPIRE key 唯一标识 过期时间</code>),并且需要设置一个获取锁的超时时间(通常远远小于锁的过期时间),如果在这个超时时间之内没有获取到锁,那么则向另外的Redis实例获取锁.</p></li><li><p>当获取到锁的时间小于锁的失效时间,并且有超过半数的Redis实例上成功获取到锁时,锁才算获取成功.</p></li><li><p>如果锁没有获取成功(在锁过期前没有获取到锁或者没有在超过半数的实例上获取到锁),那么向所有的Redis实例进行一个解锁操作,即使某个Redis实例上并没有成功获取到锁.</p></li></ol><h3 id="持久化对分布式锁的影响"><a href="#持久化对分布式锁的影响" class="headerlink" title="持久化对分布式锁的影响"></a>持久化对分布式锁的影响</h3><p>假如我们没有使用持久化,那么实例重启之后key就会消失,其它服务就有可能获取到锁.比如本来在5台机器中的3台中成功获取到锁,此时挂掉一台,那么重启后没有设置key的实例就变成了3台(半数以上),其他的请求就可能获取到锁.为了保证可靠性,需要开启持久化模式,并设置<code>fsync=always</code>来保证数据不丢失.</p><h3 id="锁失效了怎么办"><a href="#锁失效了怎么办" class="headerlink" title="锁失效了怎么办"></a>锁失效了怎么办</h3><p>还有这样一个问题,假如我们获取到锁之后,做一个业务操作,这个业务操作在超过了锁的失效时间前还没有完成,那么其它的请求就有可能获取到分布式锁,这样破坏了锁的安全性.针对这种情况,可以在业务操作没有完成之前对锁的失效时间做一个延长,主要的步骤如下:</p><ol><li>获取到分布式锁</li><li>在获取到锁的机器上开启定时任务,根据唯一标识对获取到的key延长过期时间(使用lua脚本).</li><li>等到操作完成之后,我们就会释放该锁,这样这个key不可能再延长过期时间.</li></ol><p>通过这种方式,可以保证在业务操作完成之前,锁不会被释放.另外由于这个定时任务是在获取锁的机器上开启的,那么当这台机器挂了之后,也不会有定时任务对这个key进行一个过期时间的延长,还是可以满足机器挂掉之后key能够在过期时间到来时释放.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
</feed>
