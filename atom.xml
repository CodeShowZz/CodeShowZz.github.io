<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DreamLin&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-16T17:07:19.946Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>DreamLin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/05/17/concurrentHashMap/"/>
    <id>http://example.com/2023/05/17/concurrentHashMap/</id>
    <published>2023-05-16T17:00:11.445Z</published>
    <updated>2023-05-16T17:07:19.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ConcurrencyHashMap"><a href="#ConcurrencyHashMap" class="headerlink" title="ConcurrencyHashMap"></a>ConcurrencyHashMap</h2><p>两个线程同时操作一个concurrtHashMap,但是ConcurrentHashMap的table一开始是空的,如何做到只初始化一次呢?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HashMap的实现原理</title>
    <link href="http://example.com/2023/04/24/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/04/24/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-04-23T17:07:07.000Z</published>
    <updated>2023-04-23T17:07:07.089Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>HashMap的实现原理是什么样的?在面试中经常会遇到这个问题.那这个问题实际上是要问哪些问题呢,能不能将这个问题细化一下,表达得更精确一点.在我看来,通常要要问以下几个问题:</p><ol><li>HashMap的数据结构</li><li>HashMap的hash方法是什么样的,为什么要这么实现</li><li>HashMap的负载因子是什么,有什么用</li><li>HashMap是如何扩容的</li><li>HashMap的get方法和put方法是如何实现的</li></ol><p>把这些问题弄懂之后,对HashMap的原理算是很大程度的理解了.</p><h3 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h3><p>首先,我直接通过源码的方式提取出一些HashMap中一些重要的字段,在一些字段上标明了注释,在这里不关注太多的细节,只把最重要及最精华的部分拿出来讲,源码中有太多的细节实现,我觉得没有必要死抠一些可能暂时不太有用的东西,能把大体的实现思路说清楚是我的目的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//节点数组,在必要的时候会进行扩容,长度总是2的幂次方</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-comment">//键的hash值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>  <span class="hljs-comment">//下一个节点,以链表的形式连接</span><br>        Node&lt;K,V&gt; next;<br>&#125; <br><br><span class="hljs-comment">//当链表中的数量大于等于8时,为了提高查询性能,将会转成红黑树来进行存储</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">//默认的负载因子,用于判断是否扩容</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">//默认的初始容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">//在Map中的键值对数量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">//下一次扩容的大小</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">//负载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></td></tr></table></figure><p>HashMap由数组+链表(可能转换成红黑树)组成,数组的优点是可以通过索引直接进行访问,复杂度为O(1),那这个数组要多大才合理呢?另外索引该怎么计算出来才合理呢?很显然,数组不可能无限大,因为我们的内存有限.另外,索引是通过计算hash值来实现的,最理想的情况是我们通过key算出一个hash值,然后对数组的大小取模,恰好每次都能得出一个之前没有用到的索引位置上.但是显然这是不可能的,因为即使hash值不同,但是数组的大小是固定的,那么必然算出的索引有可能会一样,这就导致了碰撞,这样一来就必须在数组的一个索引位置上存放多个元素(如果key是一样的,那么对旧key对应的值进行替换).但是,我们一定会想尽可能的均匀地把元素放到数组的每个位置中,尽量少发生碰撞,因为如果碰撞太多,那么我们设置值和取值就需要遍历链表来完成.这个时候,如何计算hash值使得元素能更均匀分布变得至关重要.</p><p>在源码中,hash值的计算是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算索引的代码是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//n为当前数组大小</span><br>index = (n - <span class="hljs-number">1</span>) &amp; hash <br></code></pre></td></tr></table></figure><p>这里把这段代码放在一起是因为它们是有关联的.首先,计算索引的方式使用了&amp;操作,比如数b是2的幂次方的时候,将这个数减去-1,与另外一个数a做&amp;操作,计算的结果就相当于a%b,并且这样的效率会更高,例如17&amp;4=1,7&amp;4=3.</p><p>hash值的计算是这样的:先计算hashCode,将其右移16位,再与本来的hashCode做异或操作,如果直接用hashCode去做&amp;运算,那么可以很明显的看出是低位的值决定了最终计算出来的值是什么,因为高位&amp;0得出的值永远是0.右移的话,可以让高位也参与到整个hash的计算过程.这样的计算方式可以使得计算出来的值的分布更加随机,这跟我们上面所叙述的不谋而合.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql之MVCC原理</title>
    <link href="http://example.com/2022/11/24/Mysql%E4%B9%8BMVCC%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/11/24/Mysql%E4%B9%8BMVCC%E5%8E%9F%E7%90%86/</id>
    <published>2022-11-23T16:14:00.000Z</published>
    <updated>2022-11-23T16:32:10.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>众所周知,mysql的数据库默认隔离级别是可重复读,那么mysql是如何做到可重复读的呢.这篇文章,就来谈谈mysql的多版本控制机制,也就是MVCC.</p><h3 id="从版本链开始说起"><a href="#从版本链开始说起" class="headerlink" title="从版本链开始说起"></a>从版本链开始说起</h3><p>假设我们现在有一张表t,里面有id,name,id是主键,这个表目前是空表.现在我们开启一个事务,往里面插入一条id=1,name=mysql的数据.mysql在聚簇索引中,除了保存数据外,还保存了一个trx_id和一个roll_pointer字段,trx_id表明数据是哪个事务操作的该条数据,roll_pointer指针指向该数据的前一个版本.假设我们刚刚进行插入语句时的事务id为100,那么聚簇索引中这条数据的trx_id为100,roll_pointer指向一条insert undo记录,可以简单理解这条记录和我们的数据是一模一样的,除了它的roll pointer是空的.可以简单用一张图来描述我们现在的数据状态:</p><p> <img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8fh9g6f2wj310i0ew0ta.jpg" alt="截屏2022-11-23 下午11.27.28"></p><p>然后,假设我们开启了一个新的事务,对id=1的记录对应的name进行修改,改成了java,事务id为200.接着,又开启一个新的事务,将name又改成了spring,事务id为300.对于mysql来说,一条记录是有保存修改历史的,就像我们用的git一样,有版本的概念.mysql同样也是这样的思想,经过两次修改,最新的name是spring,trx_id为300,但是事务id为100和200的两条历史记录也会保存下来.就我们上面的上次修改来说,最终形成的数据状态是这样的:</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h8fhhgfig5j318g0ii3zc.jpg" alt="image-20221123233538573"></p><p>和insert操作不一样,update产生的历史版本记录的roll_pointer是有指向的,指向它的上一个版本.我们可以看到,新的数据已经是事务id为300的数据了,越上面的数据版本越新,这就是版本链的概念.</p><h3 id="可重复读的实现"><a href="#可重复读的实现" class="headerlink" title="可重复读的实现"></a>可重复读的实现</h3><p>说完了版本链,现在来讲讲可重复读是如何实现的.假设我们上面所说的这个场景的事务都已经提交了,那么我们开启一个新的事务,假设事务id是400,那么我们用普通的select语句去读取id为1的记录,我们再假设整个系统目前就我们这么一个事务,那么读出来的name就是spring.那假如此时系统里面还有其他事务也在修改id为1的记录呢?这里就要引出一个快照的概念,其实就是版本链上哪些数据可见的规则.在这个隔离级别下,快照会在事务开始时生成一次,并且只生成这一次.假如我开启事务id为400的事务时,系统中还有一个事务把id为1的name修改为linux,但处于未提交状态,事务的id为399.这个未提交状态是在我们开启事务id为400的时候知道的,如果下一秒这个事务都提交了,我们的快照也是认为没有提交的.另外,假设此时快照生成后,还有事务id比400还大的事务被创建来修改id为1的记录,即使这些事务提交了,快照也会认为它们没有提交,因为在快照看来,时间就仿佛冻结在开启事务的那一刻.</p><p>比如说,当事务id为400的事务对id进行一个select name from t where id =1的查询,那么获取到的值是spring.然后事务id为399的事务提交了,事务id为400的事务再次运行同样的查询语句,那么返回的name还是spring.因为我们这两次查询用的是同一个快照,那么即使事务id为399修改了数据之后提交,我们也认为它是没有提交的,简单的理解就是:只认为在事务开启前那一刻已提交的数据才是查得到的.这样,无论事务id为400所在的事务查询多少次,查出来的name永远都是spring.除此之外,在事务id为400的事务在查询中,可能会有新的事务也来修改这个值,但是我们知道,快照对这些事务是不可见的,所以更加读不到它们的修改.但是,这些当时还在运行中的事务和后来运行的事务对id=1的记录的修改是会加入到版本链中的(即使事务还没提交),我们只是依据快照,自版本链的顶部往下搜索,过滤掉一些不可见的记录,直到找到第一条符合的记录,也就是快照开启时已提交的最新的一个版本对应的记录.其实可以画图,将所有的这些记录都加入到版本链中,来模拟这个过程.但是画图实现太费时间了,所以我就懒得画了.</p><h3 id="如果是读已提交隔离级别呢"><a href="#如果是读已提交隔离级别呢" class="headerlink" title="如果是读已提交隔离级别呢"></a>如果是读已提交隔离级别呢</h3><p>对于已提交隔离级别来说.也是生成快照,但是它和可重复读不一样的一点是,只要查询,就生成一个新的快照.这样一来,因为快照会变化,所以中途如果有数据提交了,在这个隔离级别下是可以读得到的.比如将上面的例子换成在这个隔离级别下进行实验,第二次查询出来的name将会是linux.因为第一次查询时,事务id为399的事务还没有提交,生成的快照认为此条数据是读不到的.但是第二次查询,又生成了新的快照,事务id为399的事务提交了,再次查询就可以读到linux这个值.</p><p>所以,这两个隔离级别下都是读已提交的数据.只是因为快照的生成时机不一样,导致最终读取的数据不一样而已.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>怎么保证kafka的消息不丢失</title>
    <link href="http://example.com/2022/11/08/%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81kafka%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <id>http://example.com/2022/11/08/%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81kafka%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</id>
    <published>2022-11-08T14:59:00.000Z</published>
    <updated>2022-11-08T16:44:27.637Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h3 id="从一个场景开始"><a href="#从一个场景开始" class="headerlink" title="从一个场景开始"></a>从一个场景开始</h3><p>这篇文章,我来谈谈怎么保证kafka的消息不丢失这个话题.首先,我来假设一个场景,现在你要处理客户往银行卡充值的事件,比如A用户向银行卡充值100元,200元等类似的事件.假设你使用一个项目来把这个事件发给kafka,另外一个项目从kafka获取这个事件,然后对事件进行处理,往数据库里客户的银行卡上累加金额.这个场景如果把事件丢失了,那就是事故了.我们的系统绝对不允许有任何的差错,一旦出错,客户会投诉,别人就不敢用这个系统了.有了这样的场景,我们必须认真的去考虑怎么保证消息不丢失,并且能正确处理这些消息.我们的整个架构可以用下图来表示:</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h7y75twn13j312t0u0t9z.jpg" alt="截屏2022-11-08 下午11.16.04"></p><p>我们来简单举个例子,什么情况会丢失消息.</p><ul><li><p>假如用户发起充值,这个时候项目A要发送充值事件到kafka,如果项目A没等到kafka响应,就认为事件提交成功了,那么就会丢失消息.这是生产者丢失消息的情况.</p></li><li><p>如果kafka没有把消息存入到磁盘,突然发生宕机.这是kafka丢失消息的情况.</p></li><li><p>如果项目B读取到消息后,还没将数据存储到数据库,提前告诉kafka消息已经处理完成.但这时数据库存储数据时发生错误了,那么消息就丢失了.这是消费者丢失消息的情况.</p></li></ul><p>这里只是举点简单的例子来表明消息丢失的情况,当然还会有很多场景也会造成消息的丢失,但是万变不离其宗.这里想表达的是,消息会不会丢失,不只是kafka的责任,生产者和消费者也承担着责任.要保证消息不丢失,这些环节都得考虑.</p><h3 id="生产者怎么保证消息不丢失"><a href="#生产者怎么保证消息不丢失" class="headerlink" title="生产者怎么保证消息不丢失"></a>生产者怎么保证消息不丢失</h3><p>生产者要保证消息不丢失,一定要等到kafka响应成功了,才放弃发送消息.如果消息发出去,比如kafka目前不可用了,那我们要继续重试去发送消息.比如网络异常了,在10秒内没有收到kafka的响应,我们也要重试去发送消息.总之生产者遇到错误了,解决之道就是不断重试(当然,在实际场景要灵活变通,我在这里有点激进,主要是想传达这种思想).直到生产者收到kafka的成功响应了,我们才能认为消息已经成功发送到kafka了.但这可能还不够,生产者还可以让kafka多做点事情,生产者可以要求kafka要把消息备份多少份,才能算消息发送成功.因为一台kafka机器(准确来说是分区,但是这里假设读者对这个概念是清楚的)还不够安全,假如宕机了,这个时候整个系统就使用不了.所以一般会有好几台kafka机器,一台负责接收消息,另外几台复制这台机器的消息,接收消息的那台kafka叫做首领,复制消息的叫做副本.假如一台宕机了,可以选举一台新的机器作为新的首领来接受请求.生产者可以要求kafka集群备份了N份,才能够向生产者发出成功响应.这个配置,在kafka术语中叫ack.在生产者端,可以配置ack参数,比如ack=3代表消息要复制3份成功后,kafka才能认为消息写入成功,给生产者返回成功响应.ack=all则表示所有机器都复制成功了,才能返回成功响应.否则生产者一直重试直到成功.当然重试有可能会发生消息重复,这个不在我们的讨论范围.</p><p>总结起来,生产者要做两件事情保证消息不丢失:</p><ul><li>如果消息发送失败,重试直到kafka返回成功响应.</li><li>设置ack=all(或者一个比较大的值N),让kafka的所有机器(或者N台)都获取到消息,才算消息写入成功,才返回成功响应.</li></ul><h3 id="kafka怎么保证消息不丢失"><a href="#kafka怎么保证消息不丢失" class="headerlink" title="kafka怎么保证消息不丢失"></a>kafka怎么保证消息不丢失</h3><p>消息在kafka中怎么才能不丢失呢.我们假设一个完美的情况,一台kafka接收到消息,然后另外几台kafka非常迅速的从这台kafka上复制消息,整个kafka的所有机器的消息都是同步的.但是事情不可能一直这么完美,因为网络等原因,副本有可能会复制失败,那么副本就不会有首领所有的消息,直到网络恢复正常,副本把没复制到的消息从首领那里迅速复制过来,重新变成同步的.另外首领也可能宕机,那么就要重新选出一个首领来处理消息,新的首领应该具备的特点是拥有所有的消息,但是有的副本可能还没复制到最新消息,导致消息不完整.如果让这些副本成为首领,那么可能就存在最新的消息丢失的可能性,所以我们不应该让没有所有消息的副本成为首领,在kafka的世界里,术语叫做禁用不完全的首领选举,通过配置<em>unclean.leader</em>.election.enable=false来制定,我们令可kafka不可用,也不能让这种副本成为首领.</p><p>另外,我们可以规定有几台kafka拥有全部的消息才能提供给生产者写入服务,比如设置为3,那么当至少有3台机器拥有所有的消息才能提供写入服务.这个在kafka中通过min.<em>insync</em>.replicas=N这个参数配置.再结合生产者发送的ack要求,kafka可以识别ack要求,才认为消息写入成功,给生产者返回成功响应.这样可以锦上添花.</p><p>总结起来,kafka要保证三件事情保证消息不丢失:</p><ul><li><p>通过配置<em>unclean.leader</em>.election.enable=false禁用不完全的首领选举,不让非同步副本提供服务</p></li><li><p>配置min.<em>insync</em>.replicas=N,保证同步副本个数,防止首领宕机后没有其它同步副本可以提供服务,没有足够的同步副本时,不对外提供写服务.</p></li><li><p>根据ack要求,向生产者返回成功响应</p></li></ul><h3 id="消费者怎么保证消息不丢失"><a href="#消费者怎么保证消息不丢失" class="headerlink" title="消费者怎么保证消息不丢失"></a>消费者怎么保证消息不丢失</h3><p>消息目前已经安全的存储到kafka上了,消费者从kafka已经可以获取到所有的消息.这个环节可能丢失的原因是,当消费者没有成功处理消息,就告诉kafka消息处理完成,这种情况就会丢失消息,术语叫做提前提交消息偏移量.一个最简单的做法是保证消息处理成功了,再提交偏移量告诉kafka消息真正处理完成了,这样消息就真正处理到了.所以在消费者这里,没真正处理完成就是丢失,而生产者和kafka的消息丢失主要表现在数据的传输和存储上.在上面的场景中,假如消费者拉取到一个充值事件,那么只有当数据存储到数据库中了,才应该拉取下一个充值事件(这里也有点激进,其实可以把处理失败的消息存储起来,后续再处理,总之要学会变通),否则消息就会丢失.消费者在处理过程中发生错误了,就不断重试去拉取发生错误的消息,直到处理成功了,才提交偏移量,这样就能保证消息不丢失.</p><p>总结起来,消费者要做一件事情保证消息不丢失</p><ul><li>消息处理成功了,再提交偏移量,如果处理失败,重试去拉取消息,直到处理成功.</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在上面的场景中,充值事件到消费者这里已经不会丢失了,但是可能会出现消息重复.这个消息重复在我们的场景下也是一个事故,假如用户充值10元,我们因为消息多重复了几条,给用户充值了50元,那么公司将面临极大的损失,这绝对是不允许的.一个能想到的解决方案是给消息设置一个唯一标识,如果数据库中已经有该消息,则认为已经处理成功了.其实如果学会分析kafka消息怎么可能丢失,去分析消息怎么可能重复是非常轻而易举的事情.比如Kafka已经成功写入消息,但是给生产者返回成功响应时,网络出问题了,生产者误以为没有发送成功(比如设置了超时重试),那么就会重新发送消息,kafka就重复写入了一条消息.再比如,消费者成功处理了消息,但是偏移量还没提交,消费者宕机了,那么下一次拉取的消息就是重复的.消息重复是可以避免但无法杜绝的,如果kafka没办法做幂等,那么这个重担就只能交给消费者去做了.</p><p>另外,提供什么样的消息安全级别要根据场景来定,不同的场景适合不同的方案,我们的这种方案确实安全,但是为了安全可能会牺牲很多的性能,有可能因为太安全了,导致整个系统运行得非常的缓慢,消息处理的吞吐量很低,也会给系统带来灾难.总而言之,要结合真实的情况去制定一个合适的方案,灵活变通才是王道.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>对JMM与happen-before的理解</title>
    <link href="http://example.com/2022/10/29/%E5%AF%B9JMM%E4%B8%8Ehappen-before%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2022/10/29/%E5%AF%B9JMM%E4%B8%8Ehappen-before%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2022-10-29T09:59:00.000Z</published>
    <updated>2022-10-29T10:13:04.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Java-Memory-Model"><a href="#Java-Memory-Model" class="headerlink" title="Java Memory Model"></a>Java Memory Model</h3><p>编写一个程序,我们首先希望它是正确的,其次是快的,如果程序不正确,那么再快也没用.尤其在多线程环境下,如果没有很好处理并发问题,那么很容易导致数据的不一致性,这将产生严重的问题.所以,理解java内存模型-JMM是非常重要的.</p><p>首先来看一下java内存模型的组成:<img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h7m8getq6yj30hu0mujsu.jpg" alt="jmm"></p><p>我们需要知道这样一个非常非常重要的事实,在CPU中运行一个线程,线程所读取到的值可能存放于寄存器,可能存放于缓存中,这些是线程自身所能看到的数据.只有堆上的数据是所有线程都能看到的,也就是说线程共享本地内存.</p><p>我来举一个最简单的情况:</p><p>假如有这么一个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在单线程场景下,执行以下操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Number num = <span class="hljs-keyword">new</span> Number();<br>num.set(<span class="hljs-number">3</span>); <span class="hljs-comment">//设置3</span><br>print(num.get()); <span class="hljs-comment">//打印3</span><br></code></pre></td></tr></table></figure><p>毋庸置疑,这个操作绝对是没有问题的,对num这个对象设置3这个值,即使值没有被刷新到线程共享的本地内存中,帮它存放到缓存中,也不会出现问题.</p><p>那么考虑多线程场景,如果两个线程同时更新和读取a值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Number num = <span class="hljs-keyword">new</span> Number();<br>num.set(<span class="hljs-number">3</span>); <span class="hljs-comment">//设置3 A线程设置</span><br>num.set(<span class="hljs-number">4</span>)；<span class="hljs-comment">//设置4 B线程设置</span><br>print(num.get()); <span class="hljs-comment">//A线程读取</span><br></code></pre></td></tr></table></figure><p>如果程序按照这个顺序执行,那么A线程读取的值,会是3还是4呢,其实两种情况都有可能发生.如果线程B设置的值能写入本地内存,并且线程A不读取缓存中的值,也是读取本地内存中的值,那么读取的值就是3.如果线程直接读取在缓存中的值,那么就会读到3.所以这种代码是有问题的,这种叫做可见性问题.为了解决可见性问题,java提供了一个叫做<strong>volatile</strong>的修饰语,我们将类改成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么按照上面程序的执行顺序会输出什么呢?答案是会输出4.volatile修饰的变量能保证对变量读取和写入都会去直接和本地内存交互,也就是说不会经过缓存,读取直接从本地缓存读取,写入直接写入本地缓存,这样以来会很容易理解为什么会读取到4了.除此之外,volatile还有一个非常重要的特性,它会刷新线程所能看到的其他值到本地内存当中.我们再来举一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>  <br>  <span class="hljs-comment">//A线程执行该代码</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">while</span>(flag) &#123;<br>      <br>   &#125;<br>   a = a - <span class="hljs-number">1</span>; <span class="hljs-comment">//C1</span><br>     flag = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//C2</span><br>  &#125;<br>  <br>  <span class="hljs-comment">//B线程执行该代码</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">while</span>(!flag) &#123;<br>   <br>   &#125;<br>   a = a + <span class="hljs-number">1</span>; <span class="hljs-comment">//P1</span><br> flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//P2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设这里对a的操作是原子操作(其实是三个操作).那么开启两个线程执行上述代码,值都会在0和1之间徘徊,因为每当读取flag的值的时候,顺带也有把a的最新值从本地内存读出来,写入的时候也是一样的.如果volatile只能保证flag被写入本地内存,不能保证a写入到本地内存,那么a一直无法读取到另一个线程的变更,那么可能会出现a=-1或者a=-2等情况,但其实会在写入flag的值的时候,顺带写入a的值,读取的时候也是同样的道理.更新一个volatile变量,顺带把线程操作的其它变量也一起刷新到本地内存去,做这样一件顺便且合理的事情,何乐而不为呢?</p><p>但是计算机为了追求速度,会引进一些优化手段,如<strong>重排序</strong>.重排序会将一些看似没有关联的操作顺序给重新排列,以追求更高的执行速度.在上面这个代码中,P1操作可能会被排序到P2之后进行,即先更新flag的值,再更新a的值,这样一来,flag被写入到本地内存中,因为a的操作还未开始,即使被写入本地内存后还是原值,还是会产生a的值被不确定的读取问题.</p><p>为了防止这种情况,java限制对volatile的这些操作是不能被重排序的,也就是C2和P2两个操作不能被重排序.这样一来,程序就能按照我们的意愿来执行了.</p><h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen Before"></a>Happen Before</h3><p>说到Happen Before规则,有些人可能会被它拗口的一些规则给搞得头昏脑涨.我觉得只要在理解了内存模型和可见性的基础上,就不难理解这些规则了.多线程程序要正确执行,首先要满足可见性,其实要满足原子性,可见性使得操作的数据是最新的,而原子性保证操作的过程不会因为线程对数据的同时更新而导致错误结果.在本地内存中数据对线程都是可见的,但由于操作的顺序问题,也可能导致数据不准确,比如a=a+1这个操作就不是原子操作,它实际包含读取a,设置a=a+1,写入a三个操作,这样两个线程同时执行,可能由于顺序问题而导致a的值只更新了1次.总结起来,多线程下数据的正确性=可见性+原子性.只有同时满足这两点,程序才能执行正确.原子性主要靠锁或者CAS等操作来保护(这里的主题不是这个),可见性就靠java制定的一些规则来保护,比如Happen Before.</p><p>Happen Before中的一些规则,无非就是要保证可见性,在我看来,无非就是要保证数据被及时刷新到本地内存中.上面讲解的volatile其实就具备了这样的特性,比如:对volatile修饰的值的写入操作在下一次读取时总能读到正确的值.在Java并发编程实战一书中,这个规则被描述成:对volatile变量的写入操作必须在对该变量的读操作之前执行.我不知道这个是翻译问题还是什么问题,总觉得描述得很奇怪,为什么写入一定在读之前,我可以读两次再写不行吗?我的理解是说要保证读写的可见性即可,爱怎么读就怎么读!</p><p>再举一个Happen Before规则,即进入一个同步块总能从本地内存读取到线程可见的变量的最新值,退出一个同步块总能写入变量的最新值到本地内存中.这个同步块所具备的效果,不就是volatile所具备的效果吗?再加上同步代码块能保证程序是同步执行的,所以所保护的代码段就一定不会出问题,即满足了可见性和原子性两个条件.至于重排序,比如在同步代码块中,在符合逻辑的情况下(比如变量有前后依赖关系就不能乱排),爱怎么排就怎么排.</p><p>Happen Before还有其他一些规则,但总结起来,感觉就是本地内存刷新和读取规则,目的就是保证数据对所有线程的可见性,不要在一些地方直接读取缓存,或者不把缓存数据写入本地内存.所以叫Happen Before总觉得很奇怪,叫可见性规则或者Java内存刷新与读取规则可能更合适.当然,这只是个人的见解.:)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>快速排序之精彩解说</title>
    <link href="http://example.com/2022/09/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%B2%BE%E5%BD%A9%E8%A7%A3%E8%AF%B4/"/>
    <id>http://example.com/2022/09/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%B2%BE%E5%BD%A9%E8%A7%A3%E8%AF%B4/</id>
    <published>2022-09-13T19:09:00.000Z</published>
    <updated>2022-09-24T16:11:45.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="故事开始了"><a href="#故事开始了" class="headerlink" title="故事开始了"></a>故事开始了</h3><p>假设有这样一个场景,有个小学生给了你10000个数字,要你在一天之内把这些数字排好序,然后交给他.身为一个程序猿,你想到了排序算法,进而又想到了快速排序.那么快速排序是怎么实现的呢?</p><p>既然10000个数字能排序,那么6个数字也能排序,只要6个数字时,运行结果是准确的,那么这个排序算法就能通用任意个数字的排序.假设我们有这么6个数字:</p><p><code>3 7 2 1 4 6</code> .首先,快速排序要找个基准点,一般是开头的数字,在我们这个例子中是3,然后想办法把3放到数列的中间位置,使得左边的数字比3小,右边的数字比3大,然后再递归3左右两边的数组,继续使用快速排序,最后就能全局排序.所以要搞清楚,有什么办法可以做到我们要的效果.一个可行的方法是这样的:在数组的头部和尾部各放置一个指针,然后让尾巴和3进行比较,如果大于等于3,那么就往左移动,如果碰到了比3大的数,那么就停下来.另外,如果碰到了左边的指针,也要停下来,这说明我们要的效果已经达到了.说这么多,可能还不够直观,我们用图的方式来模拟这个过程.</p><p>起初,整个指针的位置是这样的:</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i3sgao46j20oc084aa2.jpg" alt="截屏2022-09-24 下午11.17.26"></p><p>指针继续向左移动,6比3大,4也比3大,直到遇到了1,比3小,这个时候右边的指针就停下来,并且在移动过程中并未碰到左边的指针.现在指针的位置是这样的:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i588myc3j20lo0883yk.jpg" alt="截屏2022-09-24 下午11.20.33"></p><p>同理,左边的指针如果小于等于3,也要向右移动,直到遇到比3大的数,或者遇到了右指针也要停下来.3等于3,向右移动,7大于3,停下来,现在指针的位置是这样的:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i40saekgj20m807smx6.jpg" alt="截屏2022-09-24 下午11.23.47"></p><p>此时,我们把两个指针所指的数字交换一下,为什么要交换呢?因为我们要使得左边的数比3小,右边的数比3大,然后就形成了下面这张图:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i44cs5kpj20m0080q2x.jpg" alt="截屏2022-09-24 下午11.29.09"></p><p>此时,两个指针还未碰到,但是我们能看到的是:右指针右边的数据全部比3大,左指针左边的数字全部比3小.这是一个很直观的现象.</p><p>接着,我们继续移动右指针,这里的7还要和3再比较一次,当然肯定是比3大,所以一定会左移.然后2比3小,右指针又停下来了:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i4btxz5cj20mq08et8q.jpg" alt="截屏2022-09-24 下午11.36.04"></p><p>然后左指针用1和3比,肯定要向右移动,然后移动过去时,发现碰到了右指针:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i4e2j0k0j20m807ugll.jpg" alt="截屏2022-09-24 下午11.38.27"></p><p>它们撞到一起去了,这个时候我们已经达到了我们的目的,这就是左右指针停下来的一个标志,我们把开头的3和此时这个位置上的2进行一个交换,那么就变成了:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6i4i06tv6j20lm08ijrd.jpg" alt="截屏2022-09-24 下午11.41.22"></p><p>卧槽!我们达到我们的终极目的:使得3左边的数字比3小,右边的数字比3大.</p><p>接下来的故事是,保持3这个位置不动,将左边的2,1当成一个数组,右边的7,4,6当成一个数组,然后再重新对每个数组搞两个指针进行移动,切记:<strong>撞到了就是成功了</strong>.那么我们可以使用递归的方式来做剩余的事情.如果数组只剩下一个元素,那么一定要结束递归,此时的结束条件是<code>i&gt;=j</code>.下面将展示快速排序的代码,也就是模拟我们现在的整个过程.</p><h3 id="快速排序代码"><a href="#快速排序代码" class="headerlink" title="快速排序代码"></a>快速排序代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] nums,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span>(i&gt;=j)&#123;<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-keyword">int</span> start = i;<br>     <span class="hljs-keyword">int</span> end = j;<br>     <span class="hljs-keyword">int</span> basic = nums[i];<br>     <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>         <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; nums[j] &gt;= basic) &#123;<br>             j--;<br>         &#125;<br>         <span class="hljs-keyword">while</span>(i&lt; j &amp;&amp; nums[i] &lt;= basic) &#123;<br>             i++;<br>         &#125;<br>         <span class="hljs-keyword">if</span>(i&lt;j) &#123;<br>             ArrayUtil.swap(nums, i, j);<br>         &#125;<br>     &#125;<br>     ArrayUtil.swap(nums,i,start);<br>     quickSort(nums,start,i-<span class="hljs-number">1</span>);<br>     quickSort(nums,i+<span class="hljs-number">1</span>,end);<br> &#125;<br></code></pre></td></tr></table></figure><p>首先代码的开始是判断是不是要结束递归,紧接着,搞出两个指针,开始和开头位置的数字进行比较.代码里面始终要判断<code>i&lt;j</code>,因为<strong>撞到了就是成功了</strong>,无需再进行下去,另外再没撞到之前,如果双方都停下来一次之后,要交换一下所指的数字,这是为了确保右边的数字比开头的数字大,左边的数字比开头的数字小.</p><p>然后,如果i和j相遇,那么一次完整的快速排序就结束了,在遇到的地方和开头的数字进行一次交换,接着再进行左右两个数组的排序,如此递归下去,直到排完.</p><h3 id="故事的最后"><a href="#故事的最后" class="headerlink" title="故事的最后"></a>故事的最后</h3><p>你轻轻松松的排完了10000个数字,写下代码的过程只用了59秒,接着你拿起了桌上那瓶95年的可乐喝了一口,顺手掏出了手机,开始刷起了你养了多年的B站号,进入了传说中的<strong>工作休息区</strong>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="http://example.com/2022/04/13/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/04/13/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-04-13T13:06:00.000Z</published>
    <updated>2023-05-16T16:23:13.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h1><p>现在,我来介绍一下五种IO模型.首先给出结论,这五种IO模型分别是</p><ul><li>阻塞式IO</li><li>非阻塞式IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步式IO</li></ul><p>当我们要执行IO操作去读取文件,那么大致的步骤分为两步:</p><ol><li>应用程序进行一个系统调用向内核请求读取文件,此时数据可能会处于准备中的状态</li><li>当数据准备好的时候,数据需要从内核缓冲区拷贝到用户缓冲区.</li></ol><p>这五种IO模型整体上都是由这两个步骤组成,只不过采用的策略不一样而已.</p><h2 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h2><p><code>阻塞式IO</code>采用的策略是:程序向内核请求读取文件,如果数据没有准备好,那么等待数据准备好,并且当数据准备好的时候,等待数据从内核缓冲区复制到用户缓冲区.意思就是说,<b>读取文件的整个过程都是处于阻塞状态,直到数据最终复制完成后返回,此时应用程序才可以继续运行</b>.所以这个过程被称为是阻塞的,用一张图来表示这个流程:</p><pre><code class=" mermaid">sequenceDiagram    应用程序-&gt;&gt;+内核: 请求数据    内核-&gt;&gt;内核: 数据准备中    内核-&gt;&gt;内核: 数据准备完成,需要从内核缓冲区复制到用户缓冲区    内核-&gt;&gt;应用程序: 返回成功     </code></pre><p>从时序图可以看出,应用程序从请求数据开始,就会进入<b>阻塞</b>状态,直到数据准备并复制完成后返回,才会解除阻塞状态,所以这种方式称之为阻塞式IO.</p><h2 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h2><p>如果使用阻塞式IO,那么有可能存在这样一种情况,程序请求数据,但数据准备时间可能非常的久,这样会使得应用程序陷入很长的阻塞状态,那么如何才能避免这种情况呢?我们可以先请求数据,但是在数据准备过程不进行等待,而是隔一段时间后去询问内核:数据是否准备好,如果数据准备好的话,再进入阻塞状态,等待数据复制完成并返回.用一张图表示是这样的:</p><pre><code class=" mermaid">sequenceDiagram    应用程序-&gt;&gt;内核: 请求数据    内核-&gt;&gt;应用程序:数据还没准备好,请等下再询问我    内核-&gt;&gt;内核: 数据准备    应用程序-&gt;&gt;内核: 数据准备好了吗    内核-&gt;&gt;应用程序: 数据还没准备好    应用程序-&gt;&gt;内核: 数据准备好了吗    内核-&gt;&gt;应用程序: 数据还没准备好    应用程序-&gt;&gt;内核: 数据准备好了吗    内核-&gt;&gt;内核: 数据准备完成,数据从内核缓冲区复制到用户缓冲区    内核-&gt;&gt;应用程序: 返回成功</code></pre><p>在应用程序询问数据是否准备好的间隔中,应用程序是可以做其他事情的,直到数据准备完成,等待数据拷贝的过程才陷入阻塞,尽管叫做<code>非阻塞IO</code>,但本质上是一阶段非阻塞,二阶段还是阻塞的.另外这个不断询问的过程通常叫做<code>轮询</code>.</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p><code>IO多路复用</code>的基本思想其实和阻塞式IO是差不多的,只不过它会<b>等待多个文件准备就绪,如果有一个或多个文件已经准备完成,那么内核会返回应用程序已准备完成的文件,应用程序可以决定是否读取已准备好的文件,然后进入阻塞状态等待数据复制并返回</b>.多路复用强调的是<code>多路</code>,等待多个文件会比等待一个文件准备完成的成功率高一点.一旦数据已准备好,这个模型可以选择读取准备好的文件,也可以决定不读取,这增加了整个过程的灵活性.如果决定读取文件,那么就会陷入阻塞状态,等待数据复制完成,并返回到应用程序,这和上面的两个模型是一样的.用一张图表示是这样的:</p><pre><code class=" mermaid">sequenceDiagram    应用程序-&gt;&gt;内核: 请求多个文件    内核-&gt;&gt;内核: 数据准备    内核-&gt;&gt;内核: 数据准备完成    内核-&gt;&gt;应用程序: 已经有数据准备完成,分别是xx文件    应用程序-&gt;&gt;内核: 读取xx文件    内核-&gt;&gt;内核: 数据从内核缓冲区复制到用户缓冲区    内核-&gt;&gt;应用程序:  返回成功  </code></pre><p>从图中可以看出,请求多个文件的数据的过程还是阻塞的,这和阻塞式IO是一样的,区别就是等待多个文件中的其中一个或多个文件数据准备完成后,不会立即进入数据复制流程,而是返回给应用程序,由应用程序决定读取哪个文件,然后再进入数据复制流程,这增加了数据读取的灵活性.从两阶段的角度来说,这种模型一阶段是阻塞的,二阶段也是阻塞的.</p><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p><code>信号驱动IO</code>的基本思想是<b>应用程序请求数据,并告知内核:数据准备好后,通知我,之后应用程序可以决定进入阻塞状态,进入数据复制阶段</b>.这个第二阶段和上面的三种模型都是一样的,只不过第一阶段加入了<code>事件通知机制</code>，等待数据准备完成,得到一个事件,然后应用程序再决定是否进行进入阻塞状态,相比阻塞式IO和IO多路复用,这种模型在第一阶段不用陷入阻塞状态,应用程序可以做其他事情.相比非阻塞IO,这种模型不必进行轮询,而是等待内核进行通知,这可以更节省一些无效的轮询.用一张图来描述这个过程是这样的:</p><pre><code class=" mermaid">sequenceDiagram    应用程序-&gt;&gt;内核: 请求数据,告知内核有数据再进行通知    内核-&gt;&gt;应用程序: 好的,等数据准备完成再告知您    内核-&gt;&gt;内核: 数据准备    内核-&gt;&gt;内核: 数据准备完成    内核-&gt;&gt;应用程序: 数据已经准备完成    应用程序-&gt;&gt;内核: 进行数据复制    内核-&gt;&gt;内核: 数据从内核缓冲区复制到用户缓冲区    内核-&gt;&gt;应用程序:  返回成功  </code></pre><p>从图中可以看出,这种模型的一阶段更加灵活.</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>那有没有哪个IO模型是完全异步的呢,答案是有的.<code>异步IO</code>模型的两个阶段就都是异步的.<b>首先应用程序向内核请求读取数据,并告知内核:数据准备完成后,进入数据复制阶段,如果数据复制完成,再通知我</b>,应用程序只要发出一个数据准备的请求,不用陷入阻塞状态,等待数据复制完成得到一个通知,就直接可以在用户数据缓冲区读取数据.用一张图描述是这样的:</p><pre><code class=" mermaid">sequenceDiagram    应用程序-&gt;&gt;内核: 请求数据,告知内核数据复制完成再通知    内核-&gt;&gt;应用程序: 好的,等数据复制完成再告知您    内核-&gt;&gt;内核: 数据准备    内核-&gt;&gt;内核: 数据准备完成,数据从内核缓冲区复制到用户缓冲区    内核-&gt;&gt;应用程序:  通知应用程序数据复制完成  </code></pre><p>从图中可以看出,应用程序在两个阶段都是异步的,应用程序只要发出一个请求数据的请求后,静静地等待一个数据准备完成的通知即可.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Unix网络编程卷一第三版6.2</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka的ack机制</title>
    <link href="http://example.com/2021/07/08/Kafka%E7%9A%84ack%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/07/08/Kafka%E7%9A%84ack%E6%9C%BA%E5%88%B6/</id>
    <published>2021-07-07T16:58:31.000Z</published>
    <updated>2021-07-07T17:09:18.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kafka的ack机制"><a href="#Kafka的ack机制" class="headerlink" title="Kafka的ack机制"></a>Kafka的ack机制</h2><p>在博客中有一篇关于Kafka消息丢失和消息重复的文章,已经有对ack进行了讨论,这里再把这个概念拿出来单独说说.</p><p>Kafka的ack机制实际上指的是生产者的ack配置,不同的配置对消息的处理方式不同,配置得越严格消息越不容易丢失,主要有以下几种配置:</p><ul><li><p><code>ack=0</code>,消息一旦发送出去,就认为是发送成功了,即使Broker没有接收到消息.</p></li><li><p><code>ack=1</code>,一旦首领接收到消息,那么会收到发送成功的响应.但是首领有可能在消息同步到其它副本前发生崩溃,其它副本成为新的首领(即使禁用了不完全的首领选举),所以这个配置还是有可能导致消息丢失的.</p></li><li><p><code>ack=all</code>,这里的all等于Broker端配置的<code>min.insync.replicas</code>的个数,如果有等于这个个数的副本接收到消息,才能收到成功响应,但是要保证消息不可能丢失,应该是要保证所有副本都能收到消息,所以要使得<code>min.insync.replicas</code>等于副本个数.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Kafka消息丢失和消息重复,解决方案</title>
    <link href="http://example.com/2021/06/30/Kafka%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D/"/>
    <id>http://example.com/2021/06/30/Kafka%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D/</id>
    <published>2021-06-30T07:17:00.000Z</published>
    <updated>2021-07-07T16:50:47.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kafka什么时候出现消息丢失和消息重复-解决方案"><a href="#Kafka什么时候出现消息丢失和消息重复-解决方案" class="headerlink" title="Kafka什么时候出现消息丢失和消息重复,解决方案"></a>Kafka什么时候出现消息丢失和消息重复,解决方案</h2><p>消息队列的参与者无非是三个:生产者、Broker以及消费者.消息丢失和消息重复在这三个参与者当中都会出现,本篇文章以这三者的角度来叙述消息丢失和消息重复问题.</p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><h4 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h4><p>如果生产者往Broker发送消息,没有等到Broker的回复,就认为是成功了,那么就可能存在生产者的消息丢失.可能由于网络原因导致消息没有到达Broker或是其它一些异常情况.生产者发送消息有一个发送确认的概念,使用<code>ack</code>来进行配置.</p><ul><li>当设置<code>ack=0</code>时,消息一旦从生产者端发送出去就认为是成功了.这种情况就很有可能出现消息丢失.</li><li>当设置<code>ack=1</code>时,会等到首领收到消息,并返回结果才算是发送成功.这种情况认为生产者已经发送成功了,对于生产者端来说不会出现消息丢失,而对于Broker来说可能存在消息丢失,主要和同步副本有关系,这个将在下面讲解.</li><li>当设置<code>ack=all</code>时,会等到首领及首领配置的最小同步副本都接收到消息,那么才算是发送成功,Broker通过<code>min.insync.replics</code>来进行配置,比如这个属性配置成2,那么要至少有2个Broker接收到消息才算成功,不会出现消息丢失,除此之外更加严格的确保消息在副本之间的一致性.</li></ul><p>所以如果要让消息不丢失,那么可以设置ack=1或者ack=all.</p><h4 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h4><p>消息重复是无法避免的情况,即使消息真正存放到Broker之中,Broker返回的响应结果也有可能由于网络原因出现丢失或者超时的可能性.这个时候生产者误以为自己没有发送成功,那么就有可能会重试发送消息,Broker再次接收到消息,那么消息就发生了重复.</p><p>这种消息重复只能在Broker端或者消费者端做逻辑上的去重处理.</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><h4 id="消息丢失-1"><a href="#消息丢失-1" class="headerlink" title="消息丢失"></a>消息丢失</h4><p>在Broker端存在三个很重要的概念:复制系数,不完全的首领选举及最小同步副本.</p><h5 id="复制系数"><a href="#复制系数" class="headerlink" title="复制系数"></a>复制系数</h5><p>复制系数表示一个分区有多少个副本,通过<code>replication.factor</code>来进行配置,很明显这个值配置得越大,消息越不容易丢失,但是复制带来的性能损耗也越大.</p><h5 id="不完全的首领选举"><a href="#不完全的首领选举" class="headerlink" title="不完全的首领选举"></a>不完全的首领选举</h5><p>不完全的首领选举表示在进行首领选举时,是否允许非同步副本成为首领,一般通过<code>unclean.leader.election</code>进行配置,如果配置成<code>true</code>,那么可能出现首领宕机,但其它副本并没有同步完成时成为新的首领,那么就可能出现消息丢失.如果配置成<code>false</code>,那么分区在旧首领重启之前就是不可用的,这种情况不会出现消息丢失.</p><p>但是可能出现这么一种情况,消息写入到首领之后,还没有同步到其它副本中,此时首领宕机了,但是其它副本还是认为自己是同步的,还是会进行首领选举产生新首领,所以使用这个配置并不能完全防止消息丢失,只能认为它具有一定的防止消息丢失的作用.</p><h5 id="最小同步副本"><a href="#最小同步副本" class="headerlink" title="最小同步副本"></a>最小同步副本</h5><p>最小同步副本是在Broker端对消息同步副本个数的约束,一般通过<code>min.insync.replicas</code>进行配置.比如配置成2,那么要保证至少有两个同步副本时分区才能对外进行写服务,否则只能提供读服务,将最小同步副本设置成分区副本的总个数,那么在Broker端就不会出现消息丢失.</p><p>所以要让消息不丢失,可以禁用不完全的首领并且或者并且最小同步副本个数为分区副本个数.</p><h4 id="消息重复-1"><a href="#消息重复-1" class="headerlink" title="消息重复"></a>消息重复</h4><p>在Broker端出现消息重复的根本原因是生产者重复发送导致的.对于Broker来说,可以根据Broker本身提供的幂等功能来进行去重.</p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><h4 id="消息丢失-2"><a href="#消息丢失-2" class="headerlink" title="消息丢失"></a>消息丢失</h4><p>消费者一般通过轮询的方式来获取消息,消息消费成功后就提交偏移量.如果消费者没有消费成功,但是提交了偏移量,那么就存在消息丢失的可能性,下一次拉取的消息就不会有本次消费失败的消息.</p><p>对于这种情况,要确保消息处理成功再提交偏移量,或者对于没有处理成功的消息,保存到数据库或者缓存中,稍后再进行处理.</p><h4 id="消息重复-2"><a href="#消息重复-2" class="headerlink" title="消息重复"></a>消息重复</h4><p>消费者如果没有成功提交偏移量或者提交了已处理成功的消息的偏移量,那么就有可能导致消息重复.对于这种情况,要确保消息处理和偏移量提交的原子性(将偏移量作为数据库表的列,通过事务处理),或者在处理消息前判断数据库中是否已经有该消息对应的记录.</p><p>除此之外,如果Broker没有对重复的消息进行去重,消费者也置之不理,那么也会出现消息重复.对于这种情况,要根据业务标识做幂等处理.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="kafka" scheme="http://example.com/categories/kafka/"/>
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper节点类型及特点</title>
    <link href="http://example.com/2021/06/30/Zookeeper%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9/"/>
    <id>http://example.com/2021/06/30/Zookeeper%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9/</id>
    <published>2021-06-29T17:35:00.000Z</published>
    <updated>2021-06-30T09:34:17.850Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Zookeeper节点类型及特点"><a href="#Zookeeper节点类型及特点" class="headerlink" title="Zookeeper节点类型及特点"></a>Zookeeper节点类型及特点</h2><p>Zookeeper共有四种节点类型:</p><ul><li><p>持久节点.持久节点指的是在Zookeeper上进行持久化的节点,除非主动进行删除,否则节点会一直存在.</p></li><li><p>持久顺序节点.在持久节点的基础上,添加了顺序.比如创建一个持久节点,那么会自动的在路径的末尾添加一个序列号.比如连续创建两次/A/B,并表示创建的是顺序节点,那么会创建<code>/A/B0000000000</code>和<code>/A/B0000000001</code>这两个持久顺序节点,如果创建的是/A/C,那么会创建<code>/A/C0000000002</code>,这是因为有一个父节点在维护这些顺序节点的顺序(从0开始递增),只要是创建带有顺序的子节点,都会使用这个顺序来作为节点的后缀.</p></li><li><p>临时节点.临时节点指的是会话结束后会被删除的节点.临时节点不能有子节点,所以临时节点一定是叶子节点.</p></li><li><p>临时顺序节点.在临时节点的基础上,添加了顺序,其创建出来的节点路径规律和持久顺序节点是类似的.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="zookeeper" scheme="http://example.com/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://example.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>CAP定理</title>
    <link href="http://example.com/2021/06/29/CAP%E5%AE%9A%E7%90%86/"/>
    <id>http://example.com/2021/06/29/CAP%E5%AE%9A%E7%90%86/</id>
    <published>2021-06-29T08:36:00.000Z</published>
    <updated>2021-06-30T09:34:05.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>CAP定理指的是在分布式环境中,只可能满足一致性、可用性、分区容错性中的其中两个,不可以三个都满足.</p><p>一致性:这里的一致性指的是强一致性,如果节点有副本,那么一旦一个节点的数据进行更新之后,那么在另外一个节点能立即获取到更新后的值.</p><p>可用性:可用性指的是在有限的时间返回正确的结果.对于不同系统来说,有限的时间是根据具体的应用场景来定义的一个合理的指标,比如对于搜索引擎而言,这个有限的时间就是一个比较短暂的时间,比如100ms.对于一个离线处理任务来说,可能长达几分钟或者几个小时.正确的结果是一个对用户来说看的懂或者说有意义的结果,比如下单成功或失败,而不是<code>NullPointer Exception</code>这种结果.</p><p>分区容错性:网络分区指的是两个网络之间由于网络问题,导致不同节点无法进行通信,各自形成一个子网络.分区容错性指的是即使出现网络分区,系统也能提供具有一致性和可用性的服务.</p><p>因为是在分布式环境下,那么网络分区是一个必然会出现的问题,所以在设计系统时,一般考虑的是系统的一致性和可用性.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式环境中的问题</title>
    <link href="http://example.com/2021/06/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/06/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-29T08:24:00.000Z</published>
    <updated>2021-06-29T08:36:11.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分布式环境中的问题"><a href="#分布式环境中的问题" class="headerlink" title="分布式环境中的问题"></a>分布式环境中的问题</h2><p>现在几乎所有的软件都是分布式环境,那么分布式环境有什么问题呢?</p><ul><li><p>通信问题.如果是单体应用,那么所有的程序逻辑都会在一台机器上进行处理,一般不会出现网络通信问题.但是在分布式环境,会涉及到不同机器之间的通信,所以可能会出现类似网络丢包等问题.</p></li><li><p>机器故障.故障一般指的是机器宕机或者僵死.如果是单体应用,那么故障之后会造成服务不可用,重启之后又可以继续进行服务.在分布式环境下,故障问题就可能发生在所有的机器上.</p></li><li><p>网络分区.在分布式环境中,机器可能部署在不同的网络环境中,有可能出现机器本身运行正常但网络出现分区的情况,即两个网络之间的通信链路出现了问题.</p></li><li><p>三态问题.如果是单体应用,那么一般来说一个请求的处理结果要么是成功或者失败.如果是分布式环境,那么可能由于网络原因出现第三种处理结果-超时.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="分布式" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper和Redis实现分布式锁的区别</title>
    <link href="http://example.com/2021/06/29/Zookeeper%E5%92%8CKafka%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/06/29/Zookeeper%E5%92%8CKafka%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-06-29T03:23:00.000Z</published>
    <updated>2021-06-29T03:34:27.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Zookeeper和Redis实现分布式锁的区别"><a href="#Zookeeper和Redis实现分布式锁的区别" class="headerlink" title="Zookeeper和Redis实现分布式锁的区别"></a>Zookeeper和Redis实现分布式锁的区别</h2><p>在网上看了关于Zookeeper和Redis实现分布式锁的区别的一些文章,感觉可能有的文章写的这两者的区别可能跟我的理解有点出入,所以这里按照自己的理解来谈谈它们的区别:</p><ul><li><p>Zookeeper实现分布式锁时,除了可以使用和redis类似的独占锁的思路,还可以监听节点变更事件,在锁可能可以获取到的情况下通知客户端再次获取锁.</p></li><li><p>Redis在获取锁时,可能需要设置过期时间,而Zookeeper通常是设置一个临时节点,在会话过期的时候自动释放锁.</p></li></ul><p>还有一些其它区别暂时还没有学习到,可能是一些算法设计或者一致性方面的内容,如果以后涉及到这部分内容,再进行补充.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://example.com/2021/06/25/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/06/25/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-25T11:49:00.000Z</published>
    <updated>2021-06-25T12:01:22.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式解决的是一种关于发布/订阅的场景,是观察者和通知者的一种交互方式.举个例子:现在很流行订阅APP的消息,那么APP就相当于通知者,我们的手机相当于观察者,当APP有消息要发布时,会遍历所有它的观察者进行消息的发送.在实际编码中,我们在描述这种关系时可能要注意将观察者抽象化,或者将通知者抽象化,如果不抽象化我们也能描述这种发布/订阅的关系,只不过代码的扩展性比较差.</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><a href="https://github.com/CodeShowZz/code-repository/tree/master/design-pattern-demo/src/main/java/com/observer">https://github.com/CodeShowZz/code-repository/tree/master/design-pattern-demo/src/main/java/com/observer</a></p><p>这里有一个简单的代码示例,将观察者和通知者进行了一定的抽象,实际应用场景中可以是使用接口进行抽象,或者使用抽象类进行抽象,总之就是代码的具体实现可能是多种多样的,重要的事情在于要把模式体现出来和要使程序具有扩展性即可,不能拘泥于某种代码写法.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2021/06/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/06/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-25T09:11:00.000Z</published>
    <updated>2021-06-25T10:26:32.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是最简单的设计模式,它用来解决一个类只可以有一个唯一实例的问题,该类提供一个访问该实例的方法.单例模式需要注意的一个点是要保证在多线程的环境下,也能保证单例.</p><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><p>如果我们在需要单例的情况再去初始化它,则叫做懒汉式单例.</p><p>通常我们会这么写一个单例模式:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Singleton <span class="hljs-function"><span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        synchronized (Singleton.class) &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">singleton == <span class="hljs-literal">null</span></span>)</span> &#123;<br>                singleton = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这么做有一个坏处,就是每次都会有锁的开销,进而有人发明了双重检查的写法:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton2</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton2</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Singleton2 <span class="hljs-function"><span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">singleton ==<span class="hljs-literal">null</span></span>)</span> &#123;<br>            synchronized (Singleton2.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> Singleton2();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种写法是有问题的,这里主要的问题在于可见性问题,有可能A线程执行了new操作,但是对象没有完全被构建,B线程获取到了这个没有完全被构建完成的对象,这样是不安全的.进而有大神发明了一个更牛逼的写法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingletonFactory</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Singleton3 <span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.singleton3;<br>    &#125;<br>    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 singleton3 = <span class="hljs-keyword">new</span> Singleton3();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton3</span> &#123;<br>       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton3</span>(<span class="hljs-params"></span>)</span> &#123;<br>           <br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法能做到懒加载方式,又能保证线程安全,堪称单例模式的最佳写法.</p><h3 id="恶汉式"><a href="#恶汉式" class="headerlink" title="恶汉式"></a>恶汉式</h3><p>如果我们在程序的初始阶段就实例化单例,则叫做恶汉式单例.</p><p>写法也是简单粗暴:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton4</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Singleton4 singleton = <span class="hljs-keyword">new</span> Singleton4();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton4</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Singleton4 <span class="hljs-title">getSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac Os Open JDK编译</title>
    <link href="http://example.com/2021/06/25/Mac%20Os%20Open%20JDK%E7%BC%96%E8%AF%91/"/>
    <id>http://example.com/2021/06/25/Mac%20Os%20Open%20JDK%E7%BC%96%E8%AF%91/</id>
    <published>2021-06-25T03:47:00.000Z</published>
    <updated>2021-06-29T07:33:34.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Open-JDK编译"><a href="#Open-JDK编译" class="headerlink" title="Open JDK编译"></a>Open JDK编译</h2><p>我们经常都会看一些源码,但有没有想过动手修改源代码呢?在平时的开发环境中,是无法直接修改源码的,如果要修改源码,那么就要获取源代码进行编译,想象一下我们可以修改源码,然后在看源码的时候加上一些注释,仿佛成为JDK的开发人员那样,是不是很有意思?编译JDK是一个比较繁琐的过程,这里以Mac OS系统为例.</p><h3 id="第一步-下载Open-JDK11"><a href="#第一步-下载Open-JDK11" class="headerlink" title="第一步:下载Open JDK11"></a>第一步:下载Open JDK11</h3><ol><li><p>进入页面 <a href="https://adoptopenjdk.net/installation.html?variant=openjdk11&jvmVariant=hotspot#x64_mac-jdk">https://adoptopenjdk.net/installation.html?variant=openjdk11&amp;jvmVariant=hotspot#x64_mac-jdk</a> 下载 tar.gz 包</p></li><li><p>解压到/Library/Java/JavaVirtualMachines,如果你有其它版本的JDK则不需要设置环境变量,否则需要设置.</p></li></ol><h3 id="第二步-下载XCode"><a href="#第二步-下载XCode" class="headerlink" title="第二步:下载XCode"></a>第二步:下载XCode</h3><p>编译过程需要使用到XCode.在我的系统里面,App Store的XCode版本并不兼容我的系统,所以要找到兼容本系统的历史版本进行下载.可以在<a href="https://developer.apple.com/download/all/?q=Xcode%2011.7">https://developer.apple.com/download/all/?q=Xcode%2011.7</a>下载.</p><p><img src="/images/open_jdk_01.png" alt="xcode历史版本查看"></p><h3 id="第三步-下载Open-JDK11源码"><a href="#第三步-下载Open-JDK11源码" class="headerlink" title="第三步:下载Open JDK11源码"></a>第三步:下载Open JDK11源码</h3><p>在<a href="http://hg.openjdk.java.net/jdk-updates/jdk11u/">http://hg.openjdk.java.net/jdk-updates/jdk11u/</a>下载zip包,解压到一个英文目录中.</p><h3 id="第四步-编译"><a href="#第四步-编译" class="headerlink" title="第四步:编译"></a>第四步:编译</h3><p>进入到下载的jdk源码目录中,使用命令<code>sh configure --with-target-bits=64 --enable-ccache --with-jvm-variants=server  --with-boot-jdk-jvmargs=&quot;-Xlint:deprecation -Xlint:unchecked&quot; --disable-warnings-as-errors --with-debug-level=slowdebug 2&gt;&amp;1 | tee configure_mac_x64.log </code>进行编译.</p><p>在我的实际编译中,遇到了这样一个错误:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">configure: error: <span class="hljs-literal">No</span> xcodebuild<span class="hljs-built_in"> tool </span><span class="hljs-keyword">and</span> <span class="hljs-literal">no</span><span class="hljs-built_in"> system </span>framework headers found, use --with-sysroot <span class="hljs-keyword">or</span> --with-sdk-name <span class="hljs-keyword">to</span> provide a path <span class="hljs-keyword">to</span> a valid SDK<br>/Users/huangjunlin/IdeaProjects/jdk11u-113c646a33d2/build/.configure-support/generated-configure.sh: line 82: 5: Bad file descriptor<br></code></pre></td></tr></table></figure><p>此时应执行<code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer</code>后再运行上面的命令.如果编译成功,将出现类似如下代码输出:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Build performance summary:</span><br><span class="hljs-string">*</span> <span class="hljs-attr">Cores to use:</span>   <span class="hljs-number">4</span><br><span class="hljs-string">*</span> <span class="hljs-attr">Memory limit:</span>   <span class="hljs-number">8192 </span><span class="hljs-string">MB</span><br><span class="hljs-string">*</span> <span class="hljs-attr">ccache status:</span>  <span class="hljs-string">Active</span> <span class="hljs-string">(3.7.1)</span><br></code></pre></td></tr></table></figure><p>之后在这个目录使用<code>make</code>命令进行编译,整个过程可能会耗费一定时间,如果执行命令有问题,记得先加上<code>sudo</code>进行尝试,还有就是如果卡在某个地方,请耐心等待,大部分情况最终都会向下执行的,不要一开始就认为它挂了.等到出现</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">Finished building <span class="hljs-keyword">target</span> <span class="hljs-string">&#x27;default (exploded-image)&#x27;</span> in configuration <span class="hljs-string">&#x27;macosx-x86_64-normal-server-slowdebug&#x27;</span><br></code></pre></td></tr></table></figure><p>在build目录出现<code>macosx-x86_64-normal-server-slowdebug/jdk</code>文件夹,那么编译就完成了.</p><h3 id="第五步-指定Idea的JDK"><a href="#第五步-指定Idea的JDK" class="headerlink" title="第五步:指定Idea的JDK"></a>第五步:指定Idea的JDK</h3><p>创建一个Idea项目,在Idea的<code>Project Structure</code>指定SDK为刚刚编译出来的jdk,路径类似为<code>/jdk11u-113c646a33d2/build/macosx-x86_64-normal-server-slowdebug/jdk</code>.</p><h3 id="第六步-下载CLion"><a href="#第六步-下载CLion" class="headerlink" title="第六步:下载CLion"></a>第六步:下载CLion</h3><p>Clion是一个C/C++的一个开发工具,我们要修改JDK的源码,可以借助这个工具来进行修改,这个工具跟Idea的风格很像,下载也很简单.下载完成之后,使用它打开<code>jdk11u-113c646a33d2/src</code>目录,我们就是在导入的文件中修改源码.</p><h3 id="第七步-修改源码并测试"><a href="#第七步-修改源码并测试" class="headerlink" title="第七步:修改源码并测试"></a>第七步:修改源码并测试</h3><p>找到<code>java.c</code>文件,添加一条输出语句,片段如下:</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-built_in">int</span><br><span class="hljs-type">JavaMain</span>(void* _args)<br>&#123;<br>    <span class="hljs-type">JavaMainArgs</span> *args = (<span class="hljs-type">JavaMainArgs</span> *)_args;<br>    printf(<span class="hljs-string">&quot;修改open jdk&quot;</span>);<br>    <span class="hljs-built_in">int</span> argc = args-&gt;argc;<br>    <span class="hljs-built_in">char</span> **argv = args-&gt;argv;<br>    <span class="hljs-built_in">int</span> mode = args-&gt;mode;<br>    <span class="hljs-built_in">char</span> *what = args-&gt;what;<br>    <span class="hljs-type">InvocationFunctions</span> ifn = args-&gt;ifn;<br></code></pre></td></tr></table></figure><p>重新运行<code>make</code>命令,进行重新编译,这次编译速度相对来说会比较快.然后在Idea用<code>main</code>方法进行测试:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>         <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果输出了<code>修改open jdk</code>;</p><p>在网上还有一些关于在Clion打断点的文章,但好像对.java上打断点没有过多的描述,我认为对看源码参考价值不大,这部分内容后续还要再研究一下.</p><p>感觉整个过程遇到了好多坑,编译JDK还是比较麻烦的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="其它" scheme="http://example.com/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>Java锁的优化</title>
    <link href="http://example.com/2021/06/24/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/06/24/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2021-06-24T11:05:00.000Z</published>
    <updated>2021-06-25T10:24:54.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java锁的优化"><a href="#Java锁的优化" class="headerlink" title="Java锁的优化"></a>Java锁的优化</h2><p>在JDK6,Java对synchronized进行了大量的改进,包括适应性自旋,锁膨胀,轻量级锁,偏向锁.</p><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><p>自旋指的是当线程获取不到锁的时候,不用直接进入挂起状态,而是执行一个忙循环,如果在忙循环结束之后能获取到锁,那么就可以减少线程切换的开销.自适应自旋通过统计自旋相关的一些参数信息,从而动态的调整执行忙循环的次数,甚至有可能跳过自旋过程.</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>如果在一个方法内部声明一个对象,并且这个对象不可能被外部的方法所访问到,但是这个对象的一些方法可能有关于锁的一些操作,这样可能会降低程序运行的性能.所以在即时编译器检查到这类操作时,会将这些关于锁操作的代码消除掉.</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>通常来说,将锁的粒度控制得小一点是一个不错的做法,但是如果某些操作,频繁的用同一个对象进行加锁和解锁,那还不如将锁的范围扩大,这就是锁粗化.</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>这部分内容还有一些疑问没有搞清楚,留待以后补充</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock和Synchronized的区别</title>
    <link href="http://example.com/2021/06/24/ReentrantLock%E5%92%8CSynchronized/"/>
    <id>http://example.com/2021/06/24/ReentrantLock%E5%92%8CSynchronized/</id>
    <published>2021-06-24T03:56:00.000Z</published>
    <updated>2021-06-25T10:24:28.976Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h2><p>有了Synchronized,为什么还要有ReentrantLock呢?这是因为在某些特定的场景,Synchronized无法提供很好的灵活性,而ReentrantLock提供了一些更高级的功能,但是同时也有一些缺点.</p><p>两者主要的区别如下:</p><ul><li>ReentrantLock可以在获取锁失败时立即退出或者在一段时间内等待锁的获取,可以防止锁顺序死锁,而Synchronized不能.</li><li>ReentrantLock可以在等待获取锁的时候响应中断,而Synchronized不能.</li><li>ReentrantLock要手动释放锁,而Synchronized能自动释放锁.</li><li>在JDK5时,ReentrantLock的性能比Synchronized好.从JDK6开始,两者性能差不多.</li><li>Synchronized是非公平锁,ReentrantLock既可以是公平锁,也可以是非公平锁.</li></ul><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>应该优先考虑使用Synchronized,因为它能够自动释放锁,这样能降低危险性.只有在需要一些高级功能时,才应该考虑ReentrantLock.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域</title>
    <link href="http://example.com/2021/06/24/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <id>http://example.com/2021/06/24/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-06-24T03:09:00.000Z</published>
    <updated>2021-06-25T12:10:23.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JVM运行时数据区域"><a href="#JVM运行时数据区域" class="headerlink" title="JVM运行时数据区域"></a>JVM运行时数据区域</h2><p>JVM运行时数据区域如下图所示:</p><p><img src="/images/jvm_runtime_area_01.png" alt="JVM运行时数据区域"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是线程私有的,指向当前线程执行的字节码行号,当线程挂起后恢复,就是通过这个计数器来知道下一条指令的执行位置.</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈是线程私有的,在方法执行的时候,会在线程中创建一个栈帧,存放局部变量表、操作数栈、动态连接、方法出口等信息,每个方法的调用到执行完毕对应栈帧的入栈和出栈过程.</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈是线程私有的,和Java虚拟机栈相似,区别在于它为Native方法服务.</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>堆是线程共享的,几乎所有的对象实例都是分配在Java堆上,另外从JDK7开始,本位于方法区的字符串常量池已经移动到了堆上.</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是线程共享的,用来存放虚拟机加载的类型信息.运行时常量池是方法区的一部分,编译期生成的各种字面量和符号引用在类加载后会存放到运行时常量池中.</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>这部分区域并不属于JVM运行时数据区域,但是JAVA里的部分技术可能使用到这部分内存,如NIO,通过Native函数库直接分配堆外内存,所以在使用时要考虑本机总内存的大小.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="http://example.com/2021/06/24/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://example.com/2021/06/24/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2021-06-23T16:34:00.000Z</published>
    <updated>2021-06-23T18:24:21.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h2><p>JVM垃圾收集器中比较经典的收集器如下图所示:</p><p><img src="/images/jvm_collectors_01.jpg" alt="jvm经典垃圾收集器"></p><p>从图中可以看到,经典垃圾收集器目前有7种,图片米色部分的是新生代收集器,浅绿色部分是老年代收集器,横跨两种颜色的G1既是新生代收集器又是老年代收集器.除了这几个收集器之外,还有一些新版本的低延迟垃圾收集器,比如Shenandoah和ZGC收集器.接下来介绍一下各个收集器.</p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>Serial是新生代垃圾收集器,具有如下特点:</p><ul><li>采取标记复制算法进行垃圾回收</li><li>垃圾回收过程会暂停用户线程,并使用单个线程对垃圾进行回收</li></ul><p>Serial是串行的意思,名字很好的反映了该收集器的特点.</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>Serial Old是老年代垃圾收集器,具有如下特点:</p><ul><li>采取标记整理算法进行垃圾回收</li><li>垃圾回收过程会暂停用户线程,并使用单个线程对垃圾进行回收</li></ul><p>和上面的Serial收集器对比,该收集器不同的点就是工作在老年代,垃圾回收的算法不一样.</p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>从名字中的New可以看出来这是一个新生代垃圾收集器,而名字中的Par代表的意思是并行,代表该收集器会同时开启多个线程来进行垃圾回收,所以可以把它认为是Serial收集器的并行回收版本,特点如下:</p><ul><li>采取标记复制算法进行垃圾回收</li><li>垃圾回收过程会暂停用户线程,并使用多个线程对垃圾进行回收</li></ul><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>这个收集器也是新生代收集器,其基本特点与ParNew一模一样,除此之外,还有其它特别之处,可以理解为ParNew的加强版.除了ParNew的两个特点之外,特别之处在于这是一个关注吞吐量的收集器,它可以设定两个参数来控制垃圾收集器的吞吐量.首先<code>吞吐量 = 运行用户代码时间/(运行用户代码时间+运行垃圾收集时间.)</code>第一个参数<code>-XX:MaxGCPauseMillis</code>来让垃圾收集器尽可能保证垃圾收集的停顿时间小于这个指定的时间.第二个参数<code>-XX:GCTimeRatio</code>指定了GC时间占垃圾回收时间的比值,计算方式为<code>GC占用时间比例=1/1+指定的值)</code>.除此之外,该收集器还提供了<code>-XX:UseAdaptiveSizePolicy</code>参数来根据运行情况收集性能信息来调整垃圾收集器的参数,这个叫做自适应调节策略.</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>从Old可以看出这是一个老年代收集器,其特点和Parallel Scavenge是一样的,不同之处在于它采用了标记整理算法来对老年代进行收集.</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS是老年代收集器,是以低停顿为目标的垃圾收集器,采用标记清除算法来清除垃圾,运行过程如下:</p><ol><li>初始标记,标记GC Roots能直接关联到的对象,这个过程需要停顿用户线程.</li><li>并发标记,遍历整个对象图来标记能回收的对象,这个过程可以和用户线程一起并发执行</li><li>重新标记,这个过程标记的是在并发标记时产生的新的垃圾,相当于做一个修正,这个过程需要停顿用户线程</li><li>并发清除,这个过程清理标记了的对象,可以与用户线程一起并发执行.</li></ol><p>CMS被称为低停顿并发收集器,在上面耗时比较长的2和4过程中可以做到和用户线程一起执行,在耗时比较短的1和3过程需要停顿用户线程,总体来说可以认为整个过程是和用户线程一起并发执行,其思想是非常优秀的.但是由于这种设计,也有如下几个缺点:</p><ul><li><p>占用CPU资源.因为与用户线程一起并发执行,那么肯定会和用户线程一起抢占CPU的执行权,这样就会导致用户线程的吞吐量下降,尤其是在CPU核心数较少的情况下.</p></li><li><p>无法处理浮动垃圾.因为在垃圾清除阶段,用户线程还在运行,这个时候老年代可能会产生新的对象,如果这个时候无法找到足够的内存空间进行对象的分配,将会出现Concurrent Mode Failure,此时将会停顿用户线程,改用Serial Old垃圾收集器来进行垃圾回收,这样停顿的时间就更长了.默认情况下,CMS会预留一部分内存空间来分配新对象,可以通过参数<code>-XX:CMSInitiatingOccupancyFraction</code>来指定占用内存的比例为多少时触发CMS的垃圾回收.</p></li><li><p>内存碎片导致无法分配新对象.因为CMS是基于标记清除的垃圾收集器,这会导致它产生大量的内存碎片,可能导致无法找到一块内存去分配新的对象,那么就很容易导致触发FULL GC.所以CMS提供了一个<code>CompactAtFullCollection</code>参数来使得进行Full GC前先进行内存碎片的整理,尝试去找到一块空间来分配新对象,但是这个过程需要移动对象,所以会停顿用户线程.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="jvm" scheme="http://example.com/categories/jvm/"/>
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
</feed>
